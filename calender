import React, { useState, useMemo } from 'react';
import { useQuery } from '@tanstack/react-query';
import { base44 } from '@/api/base44Client';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Avatar, AvatarFallback } from '@/components/ui/avatar';
import { Users, Eye, EyeOff, Settings } from 'lucide-react';
import { Switch } from '@/components/ui/switch';

export default function TeamCalendarPanel({ currentUser, onTeamMembersChange }) {
  const [selectedMembers, setSelectedMembers] = useState(
    new Set(JSON.parse(localStorage.getItem('selectedTeamCalendars') || '[]'))
  );
  const [showSettings, setShowSettings] = useState(false);

  const { data: teamMembers = [] } = useQuery({
    queryKey: ['teamMembers'],
    queryFn: () => base44.entities.TeamMember.list()
  });

  const { data: allUsers = [] } = useQuery({
    queryKey: ['allUsers'],
    queryFn: () => base44.entities.User.list()
  });

  // Combine team members with user data
  const teamWithUsers = useMemo(() => {
    return teamMembers.map(tm => {
      const userInfo = allUsers.find(u => u.email === tm.email);
      return {
        ...tm,
        user_id: userInfo?.id,
        full_name: userInfo?.full_name || tm.name,
        email: tm.email
      };
    }).filter(tm => tm.user_id && tm.user_id !== currentUser?.id); // Exclude current user
  }, [teamMembers, allUsers, currentUser]);

  const handleToggleMember = (memberId) => {
    const newSelected = new Set(selectedMembers);
    if (newSelected.has(memberId)) {
      newSelected.delete(memberId);
    } else {
      newSelected.add(memberId);
    }
    setSelectedMembers(newSelected);
    localStorage.setItem('selectedTeamCalendars', JSON.stringify([...newSelected]));
    
    // Notify parent component
    if (onTeamMembersChange) {
      onTeamMembersChange([...newSelected]);
    }
  };

  const handleSelectAll = () => {
    const allIds = teamWithUsers.map(tm => tm.user_id);
    setSelectedMembers(new Set(allIds));
    localStorage.setItem('selectedTeamCalendars', JSON.stringify(allIds));
    if (onTeamMembersChange) {
      onTeamMembersChange(allIds);
    }
  };

  const handleClearAll = () => {
    setSelectedMembers(new Set());
    localStorage.setItem('selectedTeamCalendars', JSON.stringify([]));
    if (onTeamMembersChange) {
      onTeamMembersChange([]);
    }
  };

  return (
    <div className="bg-white dark:bg-slate-800 rounded-xl border border-slate-200 dark:border-slate-700 p-4">
      <div className="flex items-center justify-between mb-4">
        <div className="flex items-center gap-2">
          <Users className="w-4 h-4 text-indigo-600" />
          <h3 className="font-semibold text-slate-900 dark:text-white">Team Calendars</h3>
          <Badge variant="secondary" className="text-xs">
            {selectedMembers.size}/{teamWithUsers.length}
          </Badge>
        </div>
        <Button
          variant="ghost"
          size="sm"
          onClick={() => setShowSettings(!showSettings)}
        >
          <Settings className="w-4 h-4" />
        </Button>
      </div>

      {showSettings && (
        <div className="flex gap-2 mb-4">
          <Button
            size="sm"
            variant="outline"
            onClick={handleSelectAll}
            className="flex-1"
          >
            Select All
          </Button>
          <Button
            size="sm"
            variant="outline"
            onClick={handleClearAll}
            className="flex-1"
          >
            Clear
          </Button>
        </div>
      )}

      <div className="space-y-2 max-h-64 overflow-y-auto">
        {teamWithUsers.map((member) => {
          const isSelected = selectedMembers.has(member.user_id);
          return (
            <div
              key={member.id}
              className={`flex items-center justify-between p-3 rounded-lg border transition-all cursor-pointer ${
                isSelected
                  ? 'bg-indigo-50 dark:bg-indigo-900/20 border-indigo-200 dark:border-indigo-800'
                  : 'bg-slate-50 dark:bg-slate-900 border-slate-200 dark:border-slate-700 hover:bg-slate-100 dark:hover:bg-slate-800'
              }`}
              onClick={() => handleToggleMember(member.user_id)}
            >
              <div className="flex items-center gap-3">
                <Avatar className="h-8 w-8">
                  <AvatarFallback className="text-xs bg-gradient-to-r from-indigo-500 to-purple-600 text-white">
                    {member.full_name?.charAt(0) || 'T'}
                  </AvatarFallback>
                </Avatar>
                <div>
                  <p className="text-sm font-medium text-slate-900 dark:text-white">
                    {member.full_name}
                  </p>
                  <p className="text-xs text-slate-500">{member.role}</p>
                </div>
              </div>
              <div className="flex items-center gap-2">
                {isSelected ? (
                  <Eye className="w-4 h-4 text-indigo-600" />
                ) : (
                  <EyeOff className="w-4 h-4 text-slate-400" />
                )}
                <Switch
                  checked={isSelected}
                  onCheckedChange={() => handleToggleMember(member.user_id)}
                  onClick={(e) => e.stopPropagation()}
                />
              </div>
            </div>
          );
        })}

        {teamWithUsers.length === 0 && (
          <div className="text-center py-8">
            <Users className="w-8 h-8 text-slate-300 mx-auto mb-2" />
            <p className="text-sm text-slate-500">No team members found</p>
          </div>
        )}
      </div>
    </div>
  );
}
import React, { useState, useEffect } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Switch } from "@/components/ui/switch";
import { Checkbox } from "@/components/ui/checkbox";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import { MapPin, Navigation, Clock, Calendar, AlertCircle, Video, Users, ExternalLink, Loader2, Eraser, Mail, MessageSquare, Info, Trash2, AlertTriangle, RefreshCw } from "lucide-react";
import { attomPropertyData } from "@/api/functions";
import { toast } from "sonner";
import { MapContainer, TileLayer, Marker, Polyline, Popup, useMap } from 'react-leaflet';
import L from 'leaflet';
import { base44 } from "@/api/base44Client";
import { isToday, format, parseISO, addDays, isSameDay } from "date-fns";
import { Separator } from "@/components/ui/separator";


// Fix for default Leaflet icon issue with bundlers like Webpack
delete L.Icon.Default.prototype._getIconUrl;
L.Icon.Default.mergeOptions({
  iconRetinaUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon-2x.png',
  iconUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon.png',
  shadowUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-shadow.png',
});

const MapUpdater = ({ start, end }) => {
  const map = useMap();
  useEffect(() => {
    const timer = setTimeout(() => map.invalidateSize(), 100);

    if (end) {
      const bounds = start
        ? L.latLngBounds([[start.lat, start.lng], [end.lat, end.lng]])
        : L.latLngBounds([[end.lat, end.lng]]);

      map.fitBounds(bounds, { padding: [50, 50], maxZoom: 15 });
    }

    return () => clearTimeout(timer);
  }, [start, end, map]);

  return null;
};

const RouteDrawer = ({ routePolyline }) => {
  return routePolyline ? <Polyline positions={routePolyline} color="#800080" weight={5} opacity={0.7} /> : null;
};

const MapView = ({ start, end, routePolyline }) => {
  const defaultCenter = [39.8283, -98.5795];
  const defaultZoom = 4;

  return (
    <MapContainer
      center={defaultCenter}
      zoom={defaultZoom}
      style={{ height: '250px', width: '100%', borderRadius: '8px' }}
    >
      <TileLayer
        url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
        attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
      />

      <MapUpdater start={start} end={end} />

      {start && (
        <Marker position={[start.lat, start.lng]}>
          <Popup>Your Location</Popup>
        </Marker>
      )}

      {end && (
        <Marker position={[end.lat, end.lng]}>
          <Popup>Appointment Location</Popup>
        </Marker>
      )}

      <RouteDrawer routePolyline={routePolyline} />
    </MapContainer>
  );
};

export default function AppointmentModal({
  appointment,
  clients = [],
  leads = [],
  buyers = [],
  properties = [],
  users = [],
  onSave,
  onClose,
  currentUserOffice,
  currentUser
}) {
  const getInitialState = () => ({
    title: "",
    appointment_type: "general",
    scheduled_date: format(new Date(), 'yyyy-MM-dd'),
    scheduled_time: "",
    duration_minutes: 60,
    agent_id: currentUser?.id || "",
    location_address: "",
    location_lat: null,
    location_lng: null,
    travel_time_minutes: null,
    client_id: "",
    client_name: "",
    client_email: "",
    client_phone: "",
    property_id: "",
    lead_id: "",
    buyer_id: "",
    is_virtual: false,
    virtual_meeting_url: "",
    allow_public_booking: false,
    notes: "",
    reminder_preferences: JSON.stringify({
      reminder_24h: true,
      reminder_1h: true,
      departure_reminder: true
    }),
    sms_reminders_enabled: false,
    is_recurring: false,
    recurrence_pattern: "weekly",
    recurrence_days: "",
    recurrence_end_date: "",
    working_days_only: false,
    color: "pink"
  });

  const [formData, setFormData] = useState(getInitialState());
  const [isCalculatingTravel, setIsCalculatingTravel] = useState(false);
  const [addressSuggestions, setAddressSuggestions] = useState([]);
  const [showSuggestions, setShowSuggestions] = useState(false);
  const [currentGeoLocation, setCurrentGeoLocation] = useState(null);
  const [isSearchingAddress, setIsSearchingAddress] = useState(false);
  const [routePolyline, setRoutePolyline] = useState(null);
  const [lateNoticeInfo, setLateNoticeInfo] = useState(null);
  const [isSendingUpdate, setIsSendingUpdate] = useState(false);
  const [allAppointments, setAllAppointments] = useState([]);
  const [allShowings, setAllShowings] = useState([]);
  const [allOpenHouses, setAllOpenHouses] = useState([]);
  const [timeConflicts, setTimeConflicts] = useState([]);

  useEffect(() => {
    const fetchScheduleData = async () => {
      try {
        const [appointments, showings, openHouses] = await Promise.all([
          base44.entities.Appointment.list().catch(() => []),
          base44.entities.Showing.list().catch(() => []),
          base44.entities.OpenHouse.list().catch(() => [])
        ]);
        setAllAppointments(appointments);
        setAllShowings(showings);
        setAllOpenHouses(openHouses);
      } catch (error) {
        console.error('Error fetching schedule data:', error);
      }
    };

    fetchScheduleData();
  }, []);

  useEffect(() => {
    if (appointment) {
      setFormData({
        ...getInitialState(),
        ...appointment,
        agent_id: appointment.agent_id || currentUser?.id || "",
        reminder_preferences: typeof appointment.reminder_preferences === 'string'
          ? appointment.reminder_preferences
          : JSON.stringify(appointment.reminder_preferences || { reminder_24h: true, reminder_1h: true, departure_reminder: true })
      });
    } else {
      setFormData(getInitialState());
    }
    setRoutePolyline(null);
    setAddressSuggestions([]);
    setShowSuggestions(false);
    setLateNoticeInfo(null);
  }, [appointment, currentUser]);

  useEffect(() => {
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        (position) => {
          setCurrentGeoLocation({
            lat: position.coords.latitude,
            lng: position.coords.longitude,
          });
          toast.info("Using your current location for travel estimates.");
        },
        (error) => {
          console.warn(`Geolocation error: ${error.message}`);
          toast.warning("Could not get current location. Travel time calculation will be unavailable.");
        }
      );
    }
  }, []);

  useEffect(() => {
    if (currentGeoLocation && formData.location_lat && formData.location_lng && !formData.is_virtual) {
        calculateTravelTime(formData.location_lat, formData.location_lng);
    }
  }, [currentGeoLocation, formData.location_lat, formData.location_lng, formData.is_virtual]);

  useEffect(() => {
    if (appointment && appointment.location_address && !appointment.is_virtual) {
        if (appointment.location_lat && appointment.location_lng) {
             calculateTravelTime(appointment.location_lat, appointment.location_lng);
        } else {
            geocodeAndSetLocation(appointment.location_address);
        }
    }
  }, [appointment]);

  useEffect(() => {
    if (!appointment && formData.property_id) {
      const selectedProperty = properties.find(p => p.id === formData.property_id);
      if (selectedProperty) {
        const fullAddress = `${selectedProperty.address || ''}, ${selectedProperty.city || ''}, ${selectedProperty.state || ''} ${selectedProperty.zip_code || ''}`.trim();

        if (fullAddress && fullAddress.length > 5 && !fullAddress.match(/^,+$/)) {
          setFormData(prev => ({ ...prev, location_address: fullAddress }));
          geocodeAndSetLocation(fullAddress);
        } else {
          setFormData(prev => ({
              ...prev,
              location_address: "",
              location_lat: null,
              location_lng: null,
              travel_time_minutes: null
          }));
          toast.warning("Selected property has an incomplete or invalid address. Please enter manually.");
        }
      }
    }
  }, [formData.property_id, properties, appointment]);

  const appointmentTypes = [
    // Phone Calls / Follow-ups
    { value: "follow_up_call", label: "Follow-up Call", icon: "üìû", category: "calls" },
    { value: "buyer_follow_up", label: "Buyer Follow-up Call", icon: "üì±", category: "calls" },
    { value: "seller_follow_up", label: "Seller Follow-up Call", icon: "üì±", category: "calls" },
    { value: "fsbo_follow_up", label: "FSBO Follow-up Call", icon: "üè∑Ô∏è", category: "calls" },
    { value: "lead_follow_up", label: "Lead Follow-up Call", icon: "üì≤", category: "calls" },
    { value: "cold_call", label: "Cold Call Session", icon: "‚òéÔ∏è", category: "calls" },
    
    // Meetings
    { value: "listing_appointment", label: "Listing Appointment", icon: "üè†", category: "meetings" },
    { value: "buyer_consultation", label: "Buyer Consultation", icon: "üë•", category: "meetings" },
    { value: "property_showing", label: "Property Showing", icon: "üîë", category: "meetings" },
    { value: "closing_meeting", label: "Closing Meeting", icon: "üìù", category: "meetings" },
    { value: "client_meeting", label: "Client Meeting", icon: "üíº", category: "meetings" },
    { value: "vendor_meeting", label: "Vendor Meeting", icon: "ü§ù", category: "meetings" },
    
    // Property Events
    { value: "inspection", label: "Inspection", icon: "üîç", category: "property" },
    { value: "open_house", label: "Open House", icon: "üö™", category: "property" },
    { value: "property_visit", label: "Property Visit", icon: "üè°", category: "property" },
    
    // Tasks & Other
    { value: "admin_task", label: "Admin Task", icon: "üìã", category: "tasks" },
    { value: "marketing_task", label: "Marketing Task", icon: "üì£", category: "tasks" },
    { value: "recurring_task", label: "Recurring Task", icon: "üîÑ", category: "tasks" },
    { value: "personal", label: "Personal", icon: "üë§", category: "other" },
    { value: "general", label: "General", icon: "üìÖ", category: "other" }
  ];

  const reminderPrefs = formData.reminder_preferences ? JSON.parse(formData.reminder_preferences) : {
    reminder_24h: true,
    reminder_1h: true,
    departure_reminder: true,
    sms_24h: false,
    sms_1h: false
  };

  const geocodeAndSetLocation = async (address) => {
    setIsSearchingAddress(true);
    try {
        const response = await fetch(
            `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&limit=1`,
            { headers: { 'User-Agent': 'PropertySyncCRM/1.0' } }
        );
        if (!response.ok) throw new Error('Geocoding service failed');
        const data = await response.json();

        if (data && data.length > 0) {
            const geocodedData = data[0];
            const newLat = parseFloat(geocodedData.lat);
            const newLng = parseFloat(geocodedData.lon);

            setFormData(prev => ({
              ...prev,
              location_address: address,
              location_lat: newLat,
              location_lng: newLng,
            }));
            if (!formData.is_virtual) {
              calculateTravelTime(newLat, newLng);
            }
            toast.success("Location found on map.");

        } else {
            throw new Error("Address not found via Nominatim, trying AI.");
        }
    } catch (error) {
        console.warn("Standard geocoding failed:", error.message);
        toast.info("Standard search failed. Trying advanced AI search...");

        try {
            const aiGeo = await base44.integrations.Core.InvokeLLM({
                prompt: `Return the latitude and longitude for this US address: "${address}". Return only a JSON object with "lat" and "lng" keys.`,
                add_context_from_internet: true,
                response_json_schema: {
                    type: "object",
                    properties: { lat: { type: "number" }, lng: { type: "number" } },
                    required: ["lat", "lng"]
                }
            });

            if (aiGeo && typeof aiGeo.lat === 'number' && typeof aiGeo.lng === 'number') {
                const newLat = aiGeo.lat;
                const newLng = aiGeo.lng;
                setFormData(prev => ({
                    ...prev,
                    location_address: address,
                    location_lat: newLat,
                    location_lng: newLng,
                }));
                if (!formData.is_virtual) {
                  calculateTravelTime(newLat, newLng);
                }
                toast.success("AI found the location on the map.");
            } else {
                throw new Error("AI could not geocode the address.");
            }
        } catch (aiError) {
            console.error("AI Geocoding failed:", aiError);
            toast.error("Could not find location on map. Please check the address.");
            setFormData(prev => ({ ...prev, location_address: address, location_lat: null, location_lng: null, travel_time_minutes: null }));
            setRoutePolyline(null);
        }
    } finally {
        setIsSearchingAddress(false);
    }
  };

  const searchAddress = async (query) => {
    if (query.length < 3) {
      setAddressSuggestions([]);
      setShowSuggestions(false);
      return;
    }

    setIsSearchingAddress(true);
    try {
      const response = await base44.integrations.Core.InvokeLLM({
        prompt: `Search for locations matching: "${query}"

This could be:
- A business name (e.g., "Starbucks downtown Miami", "Home Depot Orlando")
- A restaurant or cafe
- An office building or company
- A property address
- A landmark or point of interest

Return 5 real locations with their full street addresses. For businesses, include the business name in the address.

Format each result with the complete street address that can be used for navigation.`,
        add_context_from_internet: true,
        response_json_schema: {
          type: "object",
          properties: {
            addresses: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  full_address: { type: "string", description: "Full street address including business name if applicable" },
                  business_name: { type: "string", description: "Name of business if searching for a business" },
                  city: { type: "string" },
                  state: { type: "string" },
                  zip_code: { type: "string" }
                },
                required: ["full_address", "city", "state"]
              }
            }
          },
          required: ["addresses"]
        }
      });

      setAddressSuggestions(response.addresses || []);
      setShowSuggestions(true);
    } catch (error) {
      console.error("Error searching address:", error);
      toast.error("Could not fetch address suggestions. Please try again.");
      setAddressSuggestions([]);
      setShowSuggestions(false);
    } finally {
      setIsSearchingAddress(false);
    }
  };

  const handleSelectSuggestion = async (suggestion) => {
    const fullAddress = `${suggestion.business_name ? suggestion.business_name + ', ' : ''}${suggestion.full_address}, ${suggestion.city}, ${suggestion.state} ${suggestion.zip_code || ''}`.trim();
    setFormData(prev => ({ ...prev, location_address: fullAddress }));
    setShowSuggestions(false);
    setAddressSuggestions([]);
    geocodeAndSetLocation(fullAddress);
    
    // Try to fetch ATTOM data for owner info
    if (suggestion.full_address && suggestion.zip_code) {
      try {
        const ownerResult = await attomPropertyData({
          action: 'propertyDetailWithOwner',
          address: suggestion.full_address,
          address2: suggestion.zip_code
        });
        
        const ownerResponse = ownerResult?.data?.data || ownerResult?.data;
        const property = ownerResponse?.property?.[0];
        
        if (property?.owner?.owner1) {
          const owner = property.owner.owner1;
          const ownerName = owner.fullName || owner.name || 
            (owner.lastName && owner.firstName ? `${owner.firstName} ${owner.lastName}` : owner.lastName) || '';
          
          if (ownerName) {
            toast.info(`Property Owner: ${ownerName}`);
          }
        }
      } catch (e) {
        // Silent fail - owner info is supplementary
        console.log('Could not fetch owner info:', e);
      }
    }
  };

  const calculateTravelTime = async (destLat, destLng) => {
    setIsCalculatingTravel(true);
    setRoutePolyline(null);

    if (!destLat || !destLng) {
        toast.error("Destination coordinates are missing to calculate travel time.");
        setIsCalculatingTravel(false);
        return;
    }

    if (!currentGeoLocation) {
        toast.warning("Could not get your current location. Travel time can't be calculated without it. Please ensure location services are enabled.");
        setFormData(prev => ({ ...prev, travel_time_minutes: null }));
        setIsCalculatingTravel(false);
        return;
    }

    try {
        const startLat = currentGeoLocation.lat;
        const startLng = currentGeoLocation.lng;
        const startLocationDescription = "your current location";

        try {
            const response = await fetch(`https://router.project-osrm.org/route/v1/driving/${startLng},${startLat};${destLng},${destLat}?overview=full&geometries=geojson`);
            if (!response.ok) throw new Error(`Routing service failed: ${response.statusText}`);

            const data = await response.json();
            if (data.routes && data.routes.length > 0) {
                const route = data.routes[0];
                const travelTimeMinutes = Math.ceil(route.duration / 60);

                const coordinates = route.geometry.coordinates;
                const latLngs = coordinates.map(coord => [coord[1], coord[0]]);
                setRoutePolyline(latLngs);

                setFormData(prev => ({ ...prev, travel_time_minutes: travelTimeMinutes }));
                toast.success(`Estimated travel time: ${travelTimeMinutes} minutes from ${startLocationDescription}.`);
            } else {
                throw new Error("No route found by routing service.");
            }
        } catch (routingError) {
            console.warn("Primary routing service failed:", routingError.message, "Falling back to AI calculation.");
            toast.info("Primary routing failed. Trying AI fallback for travel time...");

            const aiTravel = await base44.integrations.Core.InvokeLLM({
                prompt: `Calculate the driving travel time in minutes between start coordinates (${startLat}, ${startLng}) and end coordinates (${destLat}, ${destLng}). Return only a JSON object with a 'duration_minutes' key.`,
                add_context_from_internet: true,
                response_json_schema: {
                    type: "object",
                    properties: { duration_minutes: { type: "number" } },
                    required: ["duration_minutes"]
                }
            });

            if (aiTravel && typeof aiTravel.duration_minutes === 'number') {
                const travelTimeMinutes = Math.ceil(aiTravel.duration_minutes);
                setFormData(prev => ({ ...prev, travel_time_minutes: travelTimeMinutes }));
                toast.success(`AI estimated travel time: ${travelTimeMinutes} minutes.`);
                setRoutePolyline(null);
            } else {
                toast.warning("Could not calculate a driving route via primary or fallback service. Travel time unavailable.");
                setFormData(prev => ({ ...prev, travel_time_minutes: null }));
            }
        }
    } catch (error) {
        console.error("Error in calculateTravelTime function:", error);
        toast.error(`Error calculating travel time: ${error.message}`);
        setFormData(prev => ({ ...prev, travel_time_minutes: null }));
    } finally {
        setIsCalculatingTravel(false);
    }
  };

  const handleResetLocation = () => {
    setFormData(prev => ({
      ...prev,
      location_address: "",
      location_lat: null,
      location_lng: null,
      travel_time_minutes: null,
    }));
    setAddressSuggestions([]);
    setShowSuggestions(false);
    setRoutePolyline(null);
    toast.info("Location cleared.");
  };

  const handleClientChange = (clientId) => {
    const client = [...clients, ...leads, ...buyers].find(c => c.id === clientId);
    if (client) {
      setFormData({
        ...formData,
        client_id: clientId,
        client_name: client.name || `${client.first_name || ''} ${client.last_name || ''}`.trim(),
        client_email: client.email || '',
        client_phone: client.phone || ''
      });
    } else {
      setFormData({
        ...formData,
        client_id: "",
        client_name: "",
        client_email: "",
        client_phone: ""
      });
    }
  };

  const handleSubmit = (e) => {
    e.preventDefault();

    if (!formData.title || !formData.scheduled_date || !formData.scheduled_time) {
      toast.error("Please fill in all required fields");
      return;
    }

    // Location is only required for in-person meetings/property events, not for phone calls
    const isPhoneCall = ['follow_up_call', 'buyer_follow_up', 'seller_follow_up', 'fsbo_follow_up', 'lead_follow_up', 'cold_call'].includes(formData.appointment_type);
    if (!formData.is_virtual && !formData.location_address && !isPhoneCall) {
      toast.error("Please enter a location or mark as virtual meeting");
      return;
    }

    if (formData.is_recurring) {
      if (formData.recurrence_pattern === 'weekly' && (!formData.recurrence_days || formData.recurrence_days.split(',').filter(Boolean).length === 0)) {
        toast.error("Please select at least one day for weekly recurring appointments.");
        return;
      }
      if (formData.recurrence_end_date && new Date(formData.recurrence_end_date) < new Date(formData.scheduled_date)) {
        toast.error("Recurrence end date cannot be before the scheduled start date.");
        return;
      }
    }

    onSave(formData);
  };

  const handleSendLateUpdate = async () => {
    if (!lateNoticeInfo) {
      toast.warning("Please select a delay estimate before sending an update.");
      return;
    }

    setIsSendingUpdate(true);

    const clientName = formData.client_name || "there";
    const clientEmail = formData.client_email;
    const clientPhone = formData.client_phone;
    const delayTime = lateNoticeInfo.delay;

    if (!clientEmail && !clientPhone) {
      toast.error("No client email or phone number is on record for this appointment to send an update.");
      setIsSendingUpdate(false);
      return;
    }

    const placeholderClientName = "CLIENT_NAME_PLACEHOLDER";
    const placeholderTitle = "APPOINTMENT_TITLE_PLACEHOLDER";
    const placeholderDelay = "DELAY_TIME_PLACEHOLDER";
    const placeholderYourName = "YOUR_NAME_PLACEHOLDER";

    const defaultEmailTemplate = `Hi ${placeholderClientName},\n\nThis is just a quick update regarding our scheduled appointment for "${placeholderTitle}". I am running a bit behind and now expect to arrive approximately ${placeholderDelay} minutes later than planned.\n\nMy sincere apologies for any inconvenience this may cause. I look forward to seeing you shortly.\n\nBest regards,\n${placeholderYourName}`;
    const defaultSmsTemplate = `Hi ${placeholderClientName}, this is ${placeholderYourName}. Running approximately ${placeholderDelay} min late for our appointment (${placeholderTitle}). Apologies for delay, see you soon!`;

    let emailTemplate = defaultEmailTemplate;
    let smsTemplate = defaultSmsTemplate;

    if (currentUser?.late_notification_settings) {
        try {
            const settings = JSON.parse(currentUser.late_notification_settings);
            if (settings.email_template) {
                emailTemplate = settings.email_template;
            }
            if (settings.sms_template) {
                smsTemplate = settings.sms_template;
            }
        } catch (e) {
            console.error("Could not parse late notification settings:", e);
        }
    }

    const emailBody = emailTemplate
      .replace(new RegExp(placeholderClientName, 'g'), clientName)
      .replace(new RegExp(placeholderTitle, 'g'), formData.title)
      .replace(new RegExp(placeholderDelay, 'g'), delayTime)
      .replace(new RegExp(placeholderYourName, 'g'), currentUser?.full_name || 'Your Agent');

    const smsBody = smsTemplate
      .replace(new RegExp(placeholderClientName, 'g'), clientName)
      .replace(new RegExp(placeholderTitle, 'g'), formData.title)
      .replace(new RegExp(placeholderDelay, 'g'), delayTime)
      .replace(new RegExp(placeholderYourName, 'g'), currentUser?.full_name || 'Your Agent');

    let successMessages = [];

    try {
      if (clientEmail) {
        await base44.integrations.Core.SendEmail({
          to: clientEmail,
          subject: `Update Regarding Our Appointment: ${formData.title}`,
          body: emailBody
        });
        successMessages.push("Email update sent successfully.");
      }

      if (clientPhone) {
        console.log("SMS Notification (Placeholder - would be sent if enabled):");
        console.log("To:", clientPhone);
        console.log("Message:", smsBody);
        successMessages.push("SMS is ready for future integration (no actual SMS sent).");
      }

      if (successMessages.length > 0) {
          toast.success(successMessages.join(" "));
          setLateNoticeInfo(null);
      } else {
          toast.info("No email or SMS was sent (no contact info or settings).");
      }
    } catch (error) {
      console.error("Failed to send late update:", error);
      toast.error("Failed to send update. Please try again.");
    } finally {
      setIsSendingUpdate(false);
    }
  };

  const getDepartureTime = () => {
    if (!formData.scheduled_time || !formData.travel_time_minutes) return null;

    const [hours, minutes] = formData.scheduled_time.split(':').map(Number);
    const appointmentTime = new Date();
    appointmentTime.setHours(hours, minutes, 0);

    const departureTime = new Date(appointmentTime.getTime() - (formData.travel_time_minutes * 60 * 1000));

    return departureTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
  };

  const handleFormReset = () => {
    setFormData(getInitialState());
    setRoutePolyline(null);
    setAddressSuggestions([]);
    setShowSuggestions(false);
    setLateNoticeInfo(null);
    toast.info("Form has been reset.");
  };

  const mapStartLocation = currentGeoLocation;

  const hasLocation = formData.location_lat && formData.location_lng;
  const isUpcomingToday = formData.scheduled_date && isToday(new Date(formData.scheduled_date)) && new Date() < new Date(`${formData.scheduled_date}T${formData.scheduled_time}`);

  let lateTimeOptions = [15, 30, 45, 60];
  if (currentUser?.late_notification_settings) {
      try {
          const settings = JSON.parse(currentUser.late_notification_settings);
          if (settings.times && Array.isArray(settings.times) && settings.times.length > 0) {
            lateTimeOptions = settings.times;
          }
      } catch(e) {
        console.error("Error parsing late notification settings for times:", e);
      }
  }

  const handleDelete = async () => {
    if (!appointment) {
      toast.error("Cannot delete: No appointment selected");
      return;
    }

    // Get the real appointment ID (for recurring instances, we need the original ID)
    // Recurring instances have IDs like "originalId-yyyy-MM-dd", so we extract the original ID
    let realAppointmentId = appointment.id;
    if (appointment.isRecurringInstance && appointment.data?.id) {
      realAppointmentId = appointment.data.id;
    } else if (appointment.id?.includes('-') && appointment.id?.match(/\d{4}-\d{2}-\d{2}$/)) {
      // ID contains a date suffix, extract the real ID
      realAppointmentId = appointment.id.replace(/-\d{4}-\d{2}-\d{2}$/, '');
    }

    if (!realAppointmentId) {
      toast.error("Cannot delete: Invalid appointment ID");
      return;
    }

    if (!confirm(`Are you sure you want to delete this appointment?\n\n"${formData.title}"\n\nThis action cannot be undone.`)) {
      return;
    }

    try {
      await base44.entities.Appointment.delete(realAppointmentId);
      toast.success("Appointment deleted successfully");
      onClose();
      window.dispatchEvent(new Event('refreshCounts'));
    } catch (error) {
      console.error("Error deleting appointment:", error);
      if (error.message?.includes('not found')) {
        toast.info("Appointment was already deleted");
        onClose();
        window.dispatchEvent(new Event('refreshCounts'));
      } else {
        toast.error("Failed to delete appointment. Please try again.");
      }
    }
  };

  const handleSmartTimeSelect = (time) => {
    setFormData({ ...formData, scheduled_time: time });
  };

  // Check for time conflicts when date or time changes
  useEffect(() => {
    if (!formData.scheduled_date || !formData.scheduled_time) {
      setTimeConflicts([]);
      return;
    }

    const checkDate = parseISO(formData.scheduled_date);
    const [hours, minutes] = formData.scheduled_time.split(':').map(Number);
    const duration = formData.duration_minutes || 60;
    const startTime = hours * 60 + minutes;
    const endTime = startTime + duration;

    const conflicts = [];

    // Helper to generate recurring instances for a date
    const getRecurringInstancesForDate = (apt, targetDate) => {
      if (!apt.is_recurring) return [];
      
      const startDate = parseISO(apt.scheduled_date);
      const endDate = apt.recurrence_end_date ? parseISO(apt.recurrence_end_date) : addDays(targetDate, 365);
      
      if (targetDate < startDate || targetDate > endDate) return [];
      
      // Check cancelled instances
      let cancelledInstances = [];
      if (apt.cancelled_instances) {
        try {
          cancelledInstances = JSON.parse(apt.cancelled_instances);
        } catch (e) {}
      }
      
      const dateString = format(targetDate, 'yyyy-MM-dd');
      if (cancelledInstances.includes(dateString)) return [];
      
      // Check working days
      if (apt.working_days_only) {
        const dayOfWeek = targetDate.getDay();
        if (dayOfWeek === 0 || dayOfWeek === 6) return [];
      }
      
      // Check weekly pattern
      if (apt.recurrence_pattern === 'weekly' && apt.recurrence_days) {
        const dayNames = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
        const currentDayName = dayNames[targetDate.getDay()];
        const selectedDays = apt.recurrence_days.split(',');
        if (!selectedDays.includes(currentDayName)) return [];
      }
      
      // Check monthly pattern
      if (apt.recurrence_pattern === 'monthly') {
        if (targetDate.getDate() !== startDate.getDate()) return [];
      }
      
      return [apt];
    };

    // Check appointments
    allAppointments.forEach(apt => {
      if (appointment && apt.id === appointment.id) return; // Skip self
      if (apt.status === 'cancelled' || apt.status === 'completed') return;
      
      let matchingApts = [];
      
      if (apt.is_recurring) {
        matchingApts = getRecurringInstancesForDate(apt, checkDate);
      } else if (apt.scheduled_date && isSameDay(parseISO(apt.scheduled_date), checkDate)) {
        matchingApts = [apt];
      }
      
      matchingApts.forEach(matchApt => {
        if (!matchApt.scheduled_time) return;
        
        const [aptHours, aptMinutes] = matchApt.scheduled_time.split(':').map(Number);
        const aptDuration = matchApt.duration_minutes || 60;
        const aptStartTime = aptHours * 60 + aptMinutes;
        const aptEndTime = aptStartTime + aptDuration;
        
        // Check for overlap
        if (startTime < aptEndTime && endTime > aptStartTime) {
          conflicts.push({
            type: 'appointment',
            title: matchApt.title,
            time: matchApt.scheduled_time,
            duration: aptDuration,
            isRecurring: matchApt.is_recurring
          });
        }
      });
    });

    // Check showings
    allShowings.forEach(showing => {
      if (showing.status === 'cancelled' || showing.status === 'completed') return;
      if (!showing.scheduled_date || !isSameDay(parseISO(showing.scheduled_date), checkDate)) return;
      if (!showing.scheduled_time) return;
      
      const [showHours, showMinutes] = showing.scheduled_time.split(':').map(Number);
      const showDuration = showing.duration_minutes || 30;
      const showStartTime = showHours * 60 + showMinutes;
      const showEndTime = showStartTime + showDuration;
      
      if (startTime < showEndTime && endTime > showStartTime) {
        conflicts.push({
          type: 'showing',
          title: 'Property Showing',
          time: showing.scheduled_time,
          duration: showDuration,
          isRecurring: false
        });
      }
    });

    // Check open houses
    allOpenHouses.forEach(oh => {
      if (oh.status === 'cancelled' || oh.status === 'completed') return;
      if (!oh.date || !isSameDay(parseISO(oh.date), checkDate)) return;
      if (!oh.start_time) return;
      
      const [ohHours, ohMinutes] = oh.start_time.split(':').map(Number);
      const ohDuration = 180; // Assume 3 hours for open house
      const ohStartTime = ohHours * 60 + ohMinutes;
      const ohEndTime = ohStartTime + ohDuration;
      
      if (startTime < ohEndTime && endTime > ohStartTime) {
        conflicts.push({
          type: 'openhouse',
          title: 'Open House',
          time: oh.start_time,
          duration: ohDuration,
          isRecurring: false
        });
      }
    });

    setTimeConflicts(conflicts);
  }, [formData.scheduled_date, formData.scheduled_time, formData.duration_minutes, allAppointments, allShowings, allOpenHouses, appointment]);

  return (
    <Dialog open={true} onOpenChange={onClose}>
      <DialogContent className="max-w-3xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>
            {appointment ? (appointment.is_recurring ? "Edit Recurring Event" : "Edit Event") : "Schedule New Event"}
          </DialogTitle>
        </DialogHeader>

        <div className="space-y-3 my-4">
          <div className="flex items-center justify-between">
            <h3 className="text-lg font-semibold text-slate-800 dark:text-slate-100">Route Preview</h3>
            {hasLocation && mapStartLocation && (
              <a
                href={`https://www.google.com/maps/dir/?api=1&origin=${mapStartLocation.lat},${mapStartLocation.lng}&destination=${formData.location_lat},${formData.location_lng}`}
                target="_blank"
                rel="noopener noreferrer"
                className="inline-flex items-center text-sm font-medium text-indigo-600 hover:text-indigo-800 dark:text-indigo-400 dark:hover:text-indigo-300"
              >
                Open in Google Maps <ExternalLink className="w-4 h-4 ml-1.5" />
              </a>
            )}
          </div>
          <MapView
            start={mapStartLocation}
            end={hasLocation ? { lat: formData.location_lat, lng: formData.location_lng } : null}
            routePolyline={routePolyline}
          />
        </div>

        <form onSubmit={handleSubmit} className="space-y-6">
          <div className="space-y-2">
            <Label htmlFor="appointment_type">Event Type *</Label>
            <Select
              value={formData.appointment_type}
              onValueChange={(value) => setFormData({...formData, appointment_type: value})}
            >
              <SelectTrigger>
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <div className="px-2 py-1.5 text-xs font-semibold text-slate-500 bg-slate-50 dark:bg-slate-800">üìû Phone Calls & Follow-ups</div>
                {appointmentTypes.filter(t => t.category === 'calls').map(type => (
                  <SelectItem key={type.value} value={type.value}>
                    {type.icon} {type.label}
                  </SelectItem>
                ))}
                <div className="px-2 py-1.5 text-xs font-semibold text-slate-500 bg-slate-50 dark:bg-slate-800 mt-1">ü§ù Meetings</div>
                {appointmentTypes.filter(t => t.category === 'meetings').map(type => (
                  <SelectItem key={type.value} value={type.value}>
                    {type.icon} {type.label}
                  </SelectItem>
                ))}
                <div className="px-2 py-1.5 text-xs font-semibold text-slate-500 bg-slate-50 dark:bg-slate-800 mt-1">üè† Property Events</div>
                {appointmentTypes.filter(t => t.category === 'property').map(type => (
                  <SelectItem key={type.value} value={type.value}>
                    {type.icon} {type.label}
                  </SelectItem>
                ))}
                <div className="px-2 py-1.5 text-xs font-semibold text-slate-500 bg-slate-50 dark:bg-slate-800 mt-1">üìã Tasks & Other</div>
                {appointmentTypes.filter(t => t.category === 'tasks' || t.category === 'other').map(type => (
                  <SelectItem key={type.value} value={type.value}>
                    {type.icon} {type.label}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          <div className="space-y-2">
            <Label htmlFor="title">Title *</Label>
            <Input
              id="title"
              value={formData.title}
              onChange={(e) => setFormData({...formData, title: e.target.value})}
              placeholder="e.g., Listing Presentation - 123 Main St"
              required
            />
          </div>

          <div className="space-y-2">
            <Label>Calendar Color</Label>
            <div className="flex flex-wrap gap-2">
              {[
                { value: 'pink', gradient: 'from-pink-400 to-rose-600', label: 'Pink' },
                { value: 'blue', gradient: 'from-blue-400 to-blue-600', label: 'Blue' },
                { value: 'purple', gradient: 'from-purple-400 to-purple-600', label: 'Purple' },
                { value: 'green', gradient: 'from-green-400 to-green-600', label: 'Green' },
                { value: 'orange', gradient: 'from-orange-400 to-orange-600', label: 'Orange' },
                { value: 'red', gradient: 'from-red-400 to-red-600', label: 'Red' },
                { value: 'cyan', gradient: 'from-cyan-400 to-cyan-600', label: 'Cyan' },
                { value: 'amber', gradient: 'from-amber-400 to-amber-600', label: 'Amber' },
                { value: 'emerald', gradient: 'from-emerald-400 to-emerald-600', label: 'Emerald' },
                { value: 'violet', gradient: 'from-violet-400 to-violet-600', label: 'Violet' },
                { value: 'slate', gradient: 'from-slate-400 to-slate-600', label: 'Slate' }
              ].map(color => (
                <button
                  key={color.value}
                  type="button"
                  onClick={() => setFormData({...formData, color: color.value})}
                  className={`flex items-center gap-2 px-3 py-2 rounded-lg border-2 transition-all ${
                    formData.color === color.value
                      ? 'border-slate-800 dark:border-white shadow-md scale-105'
                      : 'border-slate-200 dark:border-slate-700 hover:border-slate-400 dark:hover:border-slate-500'
                  }`}
                >
                  <div className={`w-5 h-5 rounded bg-gradient-to-r ${color.gradient} shadow-sm`} />
                  <span className="text-sm font-medium text-slate-700 dark:text-slate-300">{color.label}</span>
                </button>
              ))}
            </div>
          </div>

          {/* Date & Time */}
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            <div className="space-y-2">
              <Label htmlFor="scheduled_date">Date *</Label>
              <Input
                id="scheduled_date"
                type="date"
                value={formData.scheduled_date}
                onChange={(e) => setFormData({...formData, scheduled_date: e.target.value})}
                required
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="scheduled_time">Time *</Label>
              <Input
                id="scheduled_time"
                type="time"
                value={formData.scheduled_time}
                onChange={(e) => setFormData({...formData, scheduled_time: e.target.value})}
                required
                className={timeConflicts.length > 0 ? "border-amber-500 focus:ring-amber-500" : ""}
              />
              {formData.scheduled_date && isToday(new Date(formData.scheduled_date)) && (
                <p className="text-xs text-amber-600 dark:text-amber-400 flex items-center gap-1">
                  <Clock className="w-3 h-3" />
                  Cannot schedule past times for today
                </p>
              )}
              {timeConflicts.length > 0 && (
                <div className="mt-2 p-3 bg-amber-50 dark:bg-amber-900/20 border border-amber-200 dark:border-amber-800 rounded-lg">
                  <div className="flex items-start gap-2">
                    <AlertTriangle className="w-4 h-4 text-amber-600 dark:text-amber-400 mt-0.5 flex-shrink-0" />
                    <div>
                      <p className="text-sm font-medium text-amber-800 dark:text-amber-200">
                        Time Conflict Warning
                      </p>
                      <p className="text-xs text-amber-700 dark:text-amber-300 mt-1">
                        This time overlaps with existing events. You can still proceed if the schedule is flexible.
                      </p>
                      <div className="mt-2 space-y-1">
                        {timeConflicts.map((conflict, idx) => (
                          <div key={idx} className="text-xs text-amber-800 dark:text-amber-200 flex items-center gap-1">
                            {conflict.isRecurring && <RefreshCw className="w-3 h-3" />}
                            <span className="font-medium">{conflict.time}</span>
                            <span>-</span>
                            <span>{conflict.title}</span>
                            <span className="text-amber-600 dark:text-amber-400">({conflict.duration} min)</span>
                          </div>
                        ))}
                      </div>
                    </div>
                  </div>
                </div>
              )}
            </div>
            <div className="space-y-2">
              <Label htmlFor="duration_minutes">Duration (min)</Label>
              <Input
                id="duration_minutes"
                type="number"
                min="15"
                step="15"
                value={formData.duration_minutes}
                onChange={(e) => setFormData({...formData, duration_minutes: parseInt(e.target.value)})}
              />
            </div>
          </div>



          <Separator />

          <div className="space-y-2">
            <Label htmlFor="agent_id">Assigned Agent *</Label>
            <Select
              value={formData.agent_id}
              onValueChange={(value) => setFormData({ ...formData, agent_id: value })}
              required
            >
              <SelectTrigger>
                <SelectValue placeholder="Select an agent" />
              </SelectTrigger>
              <SelectContent>
                {currentUser && (
                  <>
                    <SelectItem key={currentUser.id} value={currentUser.id}>
                      {currentUser.full_name} (You)
                    </SelectItem>
                    {users.filter(u => u.id !== currentUser.id).length > 0 && (
                      <div className="px-2 py-1.5 text-xs font-semibold text-slate-500 dark:text-slate-400 border-b border-slate-200 dark:border-slate-700">
                        Other Team Members
                      </div>
                    )}
                  </>
                )}

                {users
                  .filter(u => u.id !== currentUser?.id)
                  .sort((a, b) => (a.full_name || '').localeCompare(b.full_name || ''))
                  .map((agent) => (
                    <SelectItem key={agent.id} value={agent.id}>
                      <div className="flex items-center gap-2">
                        <span>{agent.full_name || agent.email}</span>
                        {agent.role && (
                          <span className="text-xs text-slate-500 dark:text-slate-400">
                            ({agent.role.replace(/_/g, ' ')})
                          </span>
                        )}
                      </div>
                    </SelectItem>
                  ))}
              </SelectContent>
            </Select>
          </div>
          <Separator />

          <div className="flex items-center justify-between p-4 bg-slate-50 dark:bg-slate-800 rounded-lg">
            <div className="flex items-center gap-3">
              <Video className="w-5 h-5 text-slate-600 dark:text-slate-400" />
              <div>
                <Label htmlFor="is_virtual" className="text-base font-semibold">Virtual Meeting</Label>
                <p className="text-xs text-slate-500 dark:text-slate-400">No physical location required</p>
              </div>
            </div>
            <Switch
              id="is_virtual"
              checked={formData.is_virtual}
              onCheckedChange={(checked) => setFormData({...formData, is_virtual: checked})}
            />
          </div>

          {formData.is_virtual && (
            <div className="space-y-2">
              <Label htmlFor="virtual_meeting_url">Meeting URL</Label>
              <Input
                id="virtual_meeting_url"
                value={formData.virtual_meeting_url}
                onChange={(e) => setFormData({...formData, virtual_meeting_url: e.target.value})}
                placeholder="https://zoom.us/j/... or Google Meet link"
              />
            </div>
          )}

          {!formData.is_virtual && !['follow_up_call', 'buyer_follow_up', 'seller_follow_up', 'fsbo_follow_up', 'lead_follow_up', 'cold_call'].includes(formData.appointment_type) && (
            <div className="space-y-2">
              <Label htmlFor="location_address">Location (Search or Enter Address) *</Label>
              <div className="relative">
                <Input
                  id="location_address"
                  value={formData.location_address}
                  onChange={(e) => {
                    setFormData({...formData, location_address: e.target.value});
                    searchAddress(e.target.value);
                  }}
                  placeholder="Search business name, address, or location..."
                  required={!formData.is_virtual}
                />
                {isSearchingAddress ? (
                   <Loader2 className="w-4 h-4 absolute right-3 top-3 text-slate-400 animate-spin" />
                ) : (
                   <MapPin className="w-4 h-4 absolute right-3 top-3 text-slate-400" />
                )}

                {showSuggestions && addressSuggestions.length > 0 && (
                  <div className="absolute z-10 w-full mt-1 bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-lg shadow-lg max-h-60 overflow-y-auto">
                    {addressSuggestions.map((suggestion, idx) => (
                      <button
                        key={idx}
                        type="button"
                        onClick={() => handleSelectSuggestion(suggestion)}
                        className="w-full text-left px-4 py-3 hover:bg-slate-100 dark:hover:bg-slate-700 text-sm border-b border-slate-100 dark:border-slate-700 last:border-0"
                      >
                        <div className="flex items-start gap-2">
                          <MapPin className="w-4 h-4 text-slate-400 mt-0.5 flex-shrink-0" />
                          <div>
                            {suggestion.business_name && (
                              <div className="font-medium text-slate-900 dark:text-white">{suggestion.business_name}</div>
                            )}
                            <div className={suggestion.business_name ? "text-slate-600 dark:text-slate-400" : "text-slate-900 dark:text-white"}>
                              {suggestion.full_address}, {suggestion.city}, {suggestion.state} {suggestion.zip_code || ''}
                            </div>
                          </div>
                        </div>
                      </button>
                    ))}
                  </div>
                )}
              </div>

              <div className="mt-3 space-y-3">
                {(formData.location_address || hasLocation) && (
                   <div className="flex items-center flex-wrap gap-2">
                      <Button
                        type="button"
                        size="sm"
                        variant="outline"
                        onClick={() => calculateTravelTime(formData.location_lat, formData.location_lng)}
                        disabled={isCalculatingTravel || !formData.location_lat || !formData.location_lng}
                        className="flex-shrink-0"
                      >
                         <Navigation className="w-4 h-4 mr-2" />
                        {isCalculatingTravel ? "Recalculating..." : "Recalculate Travel"}
                      </Button>
                       <Button
                        type="button"
                        size="sm"
                        variant="ghost"
                        onClick={handleResetLocation}
                        className="text-red-600 hover:text-red-700 flex-shrink-0"
                      >
                        <Eraser className="w-4 h-4 mr-2" />
                        Clear Location
                      </Button>
                   </div>
                )}
                {formData.travel_time_minutes !== null && (
                  <div className="p-3 bg-blue-50 dark:bg-blue-900/20 rounded-lg border border-blue-200 dark:border-blue-800">
                    <div className="flex items-center gap-2">
                      <Navigation className="w-4 h-4 text-blue-600 dark:text-blue-400" />
                      <span className="text-sm font-medium text-blue-900 dark:text-blue-100">
                        Est. Travel Time: {formData.travel_time_minutes} minutes
                      </span>
                    </div>
                    {getDepartureTime() && (
                      <div className="mt-2 flex items-center gap-2">
                        <Clock className="w-4 h-4 text-amber-600 dark:text-amber-400" />
                        <span className="text-sm text-amber-900 dark:text-amber-100">
                          Suggested Departure: <strong>{getDepartureTime()}</strong>
                        </span>
                      </div>
                    )}
                  </div>
                )}

              {isUpcomingToday && (
                <div className="p-4 bg-amber-50 dark:bg-amber-900/20 rounded-lg border border-amber-200 dark:border-amber-800 space-y-3">
                   <h4 className="font-semibold text-amber-900 dark:text-amber-100">Running Late?</h4>
                   <p className="text-xs text-amber-800 dark:text-amber-200">
                     Notify the client of a delay. Email and SMS (future) options available.
                   </p>
                   <div className="flex items-center gap-2">
                      <Select
                        value={lateNoticeInfo?.delay || ""}
                        onValueChange={(value) => setLateNoticeInfo({ delay: value })}
                      >
                         <SelectTrigger className="w-full md:w-[220px]">
                            <SelectValue placeholder="Select delay time..." />
                         </SelectTrigger>
                         <SelectContent>
                            {lateTimeOptions.map(time => (
                                <SelectItem key={time} value={String(time)}>{time} minutes late</SelectItem>
                            ))}
                         </SelectContent>
                      </Select>
                      <Button
                        type="button"
                        onClick={handleSendLateUpdate}
                        disabled={isSendingUpdate || !lateNoticeInfo || !lateNoticeInfo.delay}
                        className="bg-amber-600 hover:bg-amber-700"
                      >
                        {isSendingUpdate ? <Loader2 className="w-4 h-4 animate-spin" /> : <Mail className="w-4 h-4" />}
                        <span className="ml-2 hidden md:inline">Send Update</span>
                      </Button>
                   </div>
                </div>
              )}
              </div>
            </div>
          )}

          <div className="space-y-4">
            <Label>Client Information</Label>

            <div className="space-y-2">
              <Label htmlFor="client_id">Select Existing Client</Label>
              <Select
                value={formData.client_id}
                onValueChange={handleClientChange}
              >
                <SelectTrigger>
                  <SelectValue placeholder="Select a client (optional)" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value={null}>None - Enter manually</SelectItem>
                  {clients.length > 0 && (
                    <>
                      <div className="px-2 py-1 text-xs font-semibold text-slate-500">Clients</div>
                      {clients.map(client => (
                        <SelectItem key={client.id} value={client.id}>
                          {client.name} - {client.email}
                        </SelectItem>
                      ))}
                    </>
                  )}
                  {leads.length > 0 && (
                    <>
                      <div className="px-2 py-1 text-xs font-semibold text-slate-500">Leads</div>
                      {leads.map(lead => (
                        <SelectItem key={lead.id} value={lead.id}>
                          {lead.name} - {lead.email}
                        </SelectItem>
                      ))}
                    </>
                  )}
                  {buyers.length > 0 && (
                    <>
                      <div className="px-2 py-1 text-xs font-semibold text-slate-500">Buyers</div>
                      {buyers.map(buyer => (
                        <SelectItem key={buyer.id} value={buyer.id}>
                          {buyer.first_name} {buyer.last_name} - {buyer.email}
                        </SelectItem>
                      ))}
                    </>
                  )}
                </SelectContent>
              </Select>
            </div>

            {!formData.client_id && (
              <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                <div className="space-y-2">
                  <Label htmlFor="client_name">Name</Label>
                  <Input
                    id="client_name"
                    value={formData.client_name}
                    onChange={(e) => setFormData({...formData, client_name: e.target.value})}
                    placeholder="Client name"
                  />
                </div>
                <div className="space-y-2">
                  <Label htmlFor="client_email">Email</Label>
                  <Input
                    id="client_email"
                    type="email"
                    value={formData.client_email}
                    onChange={(e) => setFormData({...formData, client_email: e.target.value})}
                    placeholder="client@example.com"
                  />
                </div>
                <div className="space-y-2">
                  <Label htmlFor="client_phone">Phone</Label>
                  <Input
                    id="client_phone"
                    type="tel"
                    value={formData.client_phone}
                    onChange={(e) => setFormData({...formData, client_phone: e.target.value})}
                    placeholder="(555) 123-4567"
                  />
                </div>
              </div>
            )}
          </div>

          {['listing_appointment', 'property_showing', 'closing_meeting', 'inspection', 'open_house', 'property_visit'].includes(formData.appointment_type) && (
            <div className="space-y-2">
              <Label htmlFor="property_id">Related Property</Label>
              <Select
                value={formData.property_id}
                onValueChange={(value) => setFormData({...formData, property_id: value})}
              >
                <SelectTrigger>
                  <SelectValue placeholder="Select property to auto-fill location (optional)" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value={null}>None</SelectItem>
                  {properties.map(prop => (
                    <SelectItem key={prop.id} value={prop.id}>
                      {prop.address} - ${prop.price?.toLocaleString()}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
          )}

          <div className="flex items-center justify-between p-4 bg-gradient-to-r from-purple-50 to-indigo-50 dark:from-purple-900/20 dark:to-indigo-900/20 rounded-lg border border-purple-200 dark:border-purple-800">
            <div className="flex items-center gap-3">
              <div className="w-10 h-10 rounded-full bg-purple-100 dark:bg-purple-900/50 flex items-center justify-center text-lg">
                üîÑ
              </div>
              <div>
                <Label htmlFor="is_recurring" className="text-base font-semibold">Recurring Event</Label>
                <p className="text-xs text-slate-600 dark:text-slate-400">Repeat this event automatically</p>
              </div>
            </div>
            <Switch
              id="is_recurring"
              checked={formData.is_recurring}
              onCheckedChange={(checked) => setFormData({...formData, is_recurring: checked})}
            />
          </div>

          {formData.is_recurring && (
            <div className="space-y-4 p-4 bg-purple-50 dark:bg-purple-900/10 rounded-lg border border-purple-200 dark:border-purple-800">
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div className="space-y-2">
                  <Label htmlFor="recurrence_pattern">Repeat Pattern *</Label>
                  <Select
                    value={formData.recurrence_pattern}
                    onValueChange={(value) => setFormData({...formData, recurrence_pattern: value})}
                  >
                    <SelectTrigger>
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="daily">Every Day</SelectItem>
                      <SelectItem value="weekly">Every Week</SelectItem>
                      <SelectItem value="monthly">Every Month</SelectItem>
                    </SelectContent>
                  </Select>
                </div>

                <div className="space-y-2">
                  <Label htmlFor="recurrence_end_date">Repeat Until</Label>
                  <Input
                    id="recurrence_end_date"
                    type="date"
                    value={formData.recurrence_end_date}
                    onChange={(e) => setFormData({...formData, recurrence_end_date: e.target.value})}
                    min={formData.scheduled_date}
                  />
                </div>
              </div>

              <div className="flex items-center justify-between p-3 bg-blue-50 dark:bg-blue-900/20 rounded-lg border border-blue-200 dark:border-blue-800">
                <div className="flex items-center gap-2">
                  <Calendar className="w-4 h-4 text-blue-600 dark:text-blue-400" />
                  <div>
                    <Label htmlFor="working_days_only" className="text-sm font-semibold cursor-pointer">
                      Working Days Only
                    </Label>
                    <p className="text-xs text-blue-700 dark:text-blue-300">
                      Skip weekends (Sat & Sun)
                    </p>
                  </div>
                </div>
                <Switch
                  id="working_days_only"
                  checked={formData.working_days_only}
                  onCheckedChange={(checked) => setFormData({...formData, working_days_only: checked})}
                />
              </div>

              {formData.recurrence_pattern === 'weekly' && (
                <div className="space-y-2">
                  <Label>Repeat On</Label>
                  <div className="flex flex-wrap gap-2">
                    {[
                      { value: 'mon', label: 'Mon' },
                      { value: 'tue', label: 'Tue' },
                      { value: 'wed', label: 'Wed' },
                      { value: 'thu', label: 'Thu' },
                      { value: 'fri', label: 'Fri' },
                      { value: 'sat', label: 'Sat' },
                      { value: 'sun', label: 'Sun' }
                    ].map(day => {
                      const selectedDays = formData.recurrence_days ? formData.recurrence_days.split(',').filter(Boolean) : [];
                      const isSelected = selectedDays.includes(day.value);

                      return (
                        <button
                          key={day.value}
                          type="button"
                          onClick={() => {
                            const days = selectedDays.filter(d => d);
                            if (isSelected) {
                              const newDays = days.filter(d => d !== day.value);
                              setFormData({...formData, recurrence_days: newDays.join(',')});
                            } else {
                              days.push(day.value);
                              setFormData({...formData, recurrence_days: days.join(',')});
                            }
                          }}
                          className={`px-4 py-2 rounded-lg text-sm font-medium transition-all ${
                            isSelected
                              ? 'bg-purple-600 text-white'
                              : 'bg-white dark:bg-slate-800 text-slate-700 dark:text-slate-300 border border-slate-300 dark:border-slate-600'
                          }`}
                        >
                          {day.label}
                        </button>
                      );
                    })}
                  </div>
                </div>
              )}

              <div className="flex items-start gap-2 p-3 bg-blue-50 dark:bg-blue-900/20 rounded-lg border border-blue-200 dark:border-blue-800">
                <AlertCircle className="w-4 h-4 text-blue-600 dark:text-blue-400 mt-0.5 flex-shrink-0" />
                <p className="text-xs text-blue-800 dark:text-blue-200">
                  This will create recurring events based on your pattern. You can edit or delete individual occurrences later.
                </p>
              </div>
            </div>
          )}

          <Separator />

          <div className="flex items-center justify-between p-4 bg-slate-50 dark:bg-slate-800 rounded-lg">
            <div className="flex items-center gap-3">
              <Users className="w-5 h-5 text-slate-600 dark:text-slate-400" />
              <div>
                <Label htmlFor="allow_public_booking" className="text-base font-semibold">
                  Allow Public Booking
                </Label>
                <p className="text-xs text-slate-500 dark:text-slate-400">
                  Let anyone book this time slot through your public calendar
                </p>
              </div>
            </div>
            <Switch
              id="allow_public_booking"
              checked={formData.allow_public_booking}
              onCheckedChange={(checked) => setFormData({...formData, allow_public_booking: checked})}
            />
          </div>

          <div className="space-y-3">
            <Label>Reminder Notifications</Label>
            
            {/* Email Reminders */}
            <div className="space-y-2 p-4 bg-slate-50 dark:bg-slate-800 rounded-lg">
              <div className="flex items-center gap-2 mb-2">
                <Mail className="w-4 h-4 text-slate-600 dark:text-slate-400" />
                <span className="text-sm font-semibold text-slate-700 dark:text-slate-300">Email Reminders</span>
              </div>
              <div className="flex items-center gap-2">
                <Checkbox
                  id="reminder_24h"
                  checked={reminderPrefs.reminder_24h}
                  onCheckedChange={(checked) => {
                    const newPrefs = { ...reminderPrefs, reminder_24h: checked };
                    setFormData({...formData, reminder_preferences: JSON.stringify(newPrefs)});
                  }}
                />
                <Label htmlFor="reminder_24h" className="text-sm cursor-pointer">
                  24 hours before
                </Label>
              </div>
              <div className="flex items-center gap-2">
                <Checkbox
                  id="reminder_1h"
                  checked={reminderPrefs.reminder_1h}
                  onCheckedChange={(checked) => {
                    const newPrefs = { ...reminderPrefs, reminder_1h: checked };
                    setFormData({...formData, reminder_preferences: JSON.stringify(newPrefs)});
                  }}
                />
                <Label htmlFor="reminder_1h" className="text-sm cursor-pointer">
                  1 hour before
                </Label>
              </div>
              <div className="flex items-center gap-2">
                <Checkbox
                  id="departure_reminder"
                  checked={reminderPrefs.departure_reminder}
                  onCheckedChange={(checked) => {
                    const newPrefs = { ...reminderPrefs, departure_reminder: checked };
                    setFormData({...formData, reminder_preferences: JSON.stringify(newPrefs)});
                  }}
                />
                <Label htmlFor="departure_reminder" className="text-sm cursor-pointer">
                  Departure reminder (based on travel time)
                </Label>
              </div>
            </div>

            {/* SMS Reminders */}
            <div className="space-y-2 p-4 bg-green-50 dark:bg-green-900/20 rounded-lg border border-green-200 dark:border-green-800">
              <div className="flex items-center gap-2 mb-2">
                <MessageSquare className="w-4 h-4 text-green-600 dark:text-green-400" />
                <span className="text-sm font-semibold text-green-700 dark:text-green-300">Text Message (SMS) Reminders</span>
                <TooltipProvider>
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <Info className="w-3 h-3 text-green-500 cursor-help" />
                    </TooltipTrigger>
                    <TooltipContent>
                      <p>SMS reminders require a client phone number.<br />SMS sending will be enabled when platform integration is activated.</p>
                    </TooltipContent>
                  </Tooltip>
                </TooltipProvider>
              </div>
              {!formData.client_phone && (
                <p className="text-xs text-amber-600 dark:text-amber-400 mb-2">
                  ‚ö†Ô∏è Add a client phone number above to enable SMS reminders
                </p>
              )}
              <div className="flex items-center gap-2">
                <Checkbox
                  id="sms_24h"
                  checked={reminderPrefs.sms_24h}
                  disabled={!formData.client_phone}
                  onCheckedChange={(checked) => {
                    const newPrefs = { ...reminderPrefs, sms_24h: checked };
                    setFormData({...formData, reminder_preferences: JSON.stringify(newPrefs)});
                  }}
                />
                <Label htmlFor="sms_24h" className={`text-sm cursor-pointer ${!formData.client_phone ? 'text-slate-400' : ''}`}>
                  24 hours before
                </Label>
              </div>
              <div className="flex items-center gap-2">
                <Checkbox
                  id="sms_1h"
                  checked={reminderPrefs.sms_1h}
                  disabled={!formData.client_phone}
                  onCheckedChange={(checked) => {
                    const newPrefs = { ...reminderPrefs, sms_1h: checked };
                    setFormData({...formData, reminder_preferences: JSON.stringify(newPrefs)});
                  }}
                />
                <Label htmlFor="sms_1h" className={`text-sm cursor-pointer ${!formData.client_phone ? 'text-slate-400' : ''}`}>
                  1 hour before
                </Label>
              </div>
            </div>
          </div>

          <div className="space-y-2">
            <Label htmlFor="notes">Notes</Label>
            <Textarea
              id="notes"
              value={formData.notes}
              onChange={(e) => setFormData({...formData, notes: e.target.value})}
              placeholder="Additional notes or agenda for this appointment..."
              className="h-24"
            />
          </div>

          <DialogFooter className="pt-4 border-t gap-2">
            {appointment && appointment.id && (
              <Button
                type="button"
                variant="destructive"
                onClick={handleDelete}
                className="mr-auto"
              >
                <Trash2 className="w-4 h-4 mr-2" />
                Delete {appointment.is_recurring ? "Recurring Event" : "Appointment"}
              </Button>
            )}
            <Button
              type="button"
              variant="destructive"
              onClick={handleFormReset}
              className={appointment && appointment.id ? "" : "mr-auto"}
            >
              <Eraser className="w-4 h-4 mr-2" />
              Clear & Reset Form
            </Button>
            <Button type="button" variant="outline" onClick={onClose}>
              Close
            </Button>
            <Button type="submit" className="bg-indigo-600 hover:bg-indigo-700">
              {appointment?.is_recurring ? "Update Recurring Event" : (appointment ? "Update Event" : "Schedule Event")}
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
}
import React, { useState, useEffect } from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Switch } from '@/components/ui/switch';
import { Label } from '@/components/ui/label';
import { base44 } from '@/api/base44Client';
import { toast } from 'sonner';
import { 
    Calendar, 
    RefreshCw, 
    CheckCircle2, 
    AlertCircle,
    Loader2,
    ExternalLink,
    Settings2
} from 'lucide-react';

export default function CalendarSyncModal({ isOpen, onClose, user, onSyncComplete }) {
    const [isGoogleConnected, setIsGoogleConnected] = useState(false);
    const [isSyncing, setIsSyncing] = useState(false);
    const [syncStats, setSyncStats] = useState(null);
    const [autoSync, setAutoSync] = useState(true);
    const [syncFrequency, setSyncFrequency] = useState('15'); // minutes

    useEffect(() => {
        if (isOpen && user) {
            checkConnection();
            loadSyncPreferences();
        }
    }, [isOpen, user]);

    const checkConnection = async () => {
        try {
            // Check if Google Calendar is authorized via app connector
            // Since the connector is already authorized, we can directly check sync function
            const response = await base44.functions.invoke('syncGoogleCalendar', {
                action: 'check_connection'
            });
            
            if (response.data?.connected) {
                setIsGoogleConnected(true);
            } else {
                setIsGoogleConnected(false);
            }
        } catch (error) {
            // If the function exists and doesn't throw auth errors, we're connected
            if (error.message?.includes('Unauthorized') || error.message?.includes('not authorized')) {
                setIsGoogleConnected(false);
            } else {
                // Function exists, likely connected but sync failed for other reasons
                setIsGoogleConnected(true);
            }
        }
    };

    const loadSyncPreferences = () => {
        if (user?.calendar_sync_preferences) {
            try {
                const prefs = JSON.parse(user.calendar_sync_preferences);
                setAutoSync(prefs.auto_sync !== false);
                setSyncFrequency(prefs.sync_frequency || '15');
            } catch (e) {
                console.error('Error parsing sync preferences:', e);
            }
        }
    };

    const handleConnectGoogle = async () => {
        // Google Calendar is already authorized via app connector
        // Just confirm the connection and trigger initial sync
        setIsGoogleConnected(true);
        toast.success('Google Calendar connected! Starting sync...');
        await handleSync();
    };

    const handleSync = async () => {
        setIsSyncing(true);
        try {
            const response = await base44.functions.invoke('syncGoogleCalendar', {
                action: 'fetch'
            });

            setSyncStats({
                synced: response.data.synced,
                timestamp: new Date().toISOString()
            });

            toast.success(`Synced ${response.data.synced} events from Google Calendar`);
            
            if (onSyncComplete) {
                onSyncComplete();
            }
        } catch (error) {
            console.error('Sync error:', error);
            toast.error('Failed to sync: ' + error.message);
        } finally {
            setIsSyncing(false);
        }
    };

    const handleSavePreferences = async () => {
        try {
            const preferences = {
                auto_sync: autoSync,
                sync_frequency: syncFrequency
            };

            await base44.auth.updateMe({
                calendar_sync_preferences: JSON.stringify(preferences)
            });

            toast.success('Sync preferences saved!');
        } catch (error) {
            toast.error('Failed to save preferences');
        }
    };

    return (
        <Dialog open={isOpen} onOpenChange={onClose}>
            <DialogContent className="max-w-md">
                <DialogHeader>
                    <DialogTitle className="flex items-center gap-2">
                        <Calendar className="w-5 h-5 text-blue-600" />
                        Calendar Sync
                    </DialogTitle>
                    <DialogDescription>
                        Connect and sync with your external calendars
                    </DialogDescription>
                </DialogHeader>

                <div className="space-y-6">
                    {/* Google Calendar Connection */}
                    <div className="border rounded-lg p-4">
                        <div className="flex items-center justify-between mb-3">
                            <div className="flex items-center gap-3">
                                <div className="w-10 h-10 rounded-lg bg-blue-100 flex items-center justify-center">
                                    <Calendar className="w-5 h-5 text-blue-600" />
                                </div>
                                <div>
                                    <h3 className="font-semibold text-sm">Google Calendar</h3>
                                    <p className="text-xs text-slate-500">
                                        {isGoogleConnected ? 'Connected' : 'Not connected'}
                                    </p>
                                </div>
                            </div>
                            {isGoogleConnected ? (
                                <Badge className="bg-green-100 text-green-700">
                                    <CheckCircle2 className="w-3 h-3 mr-1" />
                                    Active
                                </Badge>
                            ) : (
                                <Badge variant="outline" className="text-slate-500">
                                    <AlertCircle className="w-3 h-3 mr-1" />
                                    Inactive
                                </Badge>
                            )}
                        </div>

                        {!isGoogleConnected ? (
                            <Button 
                                onClick={handleConnectGoogle}
                                className="w-full bg-blue-600 hover:bg-blue-700"
                            >
                                <ExternalLink className="w-4 h-4 mr-2" />
                                Connect Google Calendar
                            </Button>
                        ) : (
                            <div className="space-y-3">
                                <Button 
                                    onClick={handleSync}
                                    disabled={isSyncing}
                                    className="w-full"
                                    variant="outline"
                                >
                                    {isSyncing ? (
                                        <>
                                            <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                                            Syncing...
                                        </>
                                    ) : (
                                        <>
                                            <RefreshCw className="w-4 h-4 mr-2" />
                                            Sync Now
                                        </>
                                    )}
                                </Button>

                                {syncStats && (
                                    <div className="bg-green-50 dark:bg-green-900/20 rounded-lg p-3">
                                        <p className="text-xs text-green-800 dark:text-green-200">
                                            <CheckCircle2 className="w-3 h-3 inline mr-1" />
                                            Last sync: {new Date(syncStats.timestamp).toLocaleString()}
                                        </p>
                                        <p className="text-xs text-green-700 dark:text-green-300 mt-1">
                                            {syncStats.synced} events synced
                                        </p>
                                    </div>
                                )}
                            </div>
                        )}
                    </div>

                    {/* Sync Preferences */}
                    {isGoogleConnected && (
                        <div className="border rounded-lg p-4 space-y-4">
                            <div className="flex items-center gap-2 mb-3">
                                <Settings2 className="w-4 h-4 text-slate-600" />
                                <h3 className="font-semibold text-sm">Sync Preferences</h3>
                            </div>

                            <div className="flex items-center justify-between">
                                <div>
                                    <Label className="text-sm font-medium">Automatic Sync</Label>
                                    <p className="text-xs text-slate-500">
                                        Sync changes automatically
                                    </p>
                                </div>
                                <Switch 
                                    checked={autoSync}
                                    onCheckedChange={setAutoSync}
                                />
                            </div>

                            {autoSync && (
                                <div>
                                    <Label className="text-sm font-medium mb-2 block">
                                        Sync Frequency
                                    </Label>
                                    <select
                                        value={syncFrequency}
                                        onChange={(e) => setSyncFrequency(e.target.value)}
                                        className="w-full border rounded-lg px-3 py-2 text-sm"
                                    >
                                        <option value="5">Every 5 minutes</option>
                                        <option value="15">Every 15 minutes</option>
                                        <option value="30">Every 30 minutes</option>
                                        <option value="60">Every hour</option>
                                    </select>
                                </div>
                            )}

                            <Button 
                                onClick={handleSavePreferences}
                                className="w-full"
                                variant="outline"
                            >
                                Save Preferences
                            </Button>
                        </div>
                    )}

                    {/* Info */}
                    <div className="bg-blue-50 dark:bg-blue-900/20 rounded-lg p-3">
                        <p className="text-xs text-blue-800 dark:text-blue-200">
                            <strong>Two-way sync:</strong> Changes made in the app will be reflected in your external calendar, and vice versa.
                        </p>
                    </div>
                </div>
            </DialogContent>
        </Dialog>
    );
}
import React, { useState, useEffect } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Switch } from "@/components/ui/switch";
import { Badge } from "@/components/ui/badge";
import { Separator } from "@/components/ui/separator";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { 
  Calendar, Clock, MapPin, Users, Mail, Bell, Video, 
  RefreshCw, Globe, Eye, Lock, Zap, Plus, X, 
  UserPlus, Settings, Copy, ChevronDown, AlertCircle, Loader2
} from "lucide-react";
import { toast } from "sonner";
import { format, parseISO, addMinutes, differenceInMinutes, isToday, isSameDay } from "date-fns";
import { base44 } from "@/api/base44Client";

const TIMEZONES = [
  { value: 'America/New_York', label: 'Eastern Time - New York', offset: 'GMT-05:00' },
  { value: 'America/Chicago', label: 'Central Time - Chicago', offset: 'GMT-06:00' },
  { value: 'America/Denver', label: 'Mountain Time - Denver', offset: 'GMT-07:00' },
  { value: 'America/Los_Angeles', label: 'Pacific Time - Los Angeles', offset: 'GMT-08:00' },
  { value: 'America/Phoenix', label: 'Arizona Time - Phoenix', offset: 'GMT-07:00' },
  { value: 'America/Anchorage', label: 'Alaska Time - Anchorage', offset: 'GMT-09:00' },
  { value: 'Pacific/Honolulu', label: 'Hawaii Time - Honolulu', offset: 'GMT-10:00' }
];

const NOTIFICATION_TIMES = [
  { value: 0, label: 'At time of event' },
  { value: 5, label: '5 minutes before' },
  { value: 10, label: '10 minutes before' },
  { value: 15, label: '15 minutes before' },
  { value: 30, label: '30 minutes before' },
  { value: 60, label: '1 hour before' },
  { value: 120, label: '2 hours before' },
  { value: 1440, label: '1 day before' },
  { value: 2880, label: '2 days before' },
  { value: 10080, label: '1 week before' }
];

const SUGGESTED_TIMES = [
  { time: '07:00', label: '7:00 AM', icon: 'üåÖ' },
  { time: '08:00', label: '8:00 AM', icon: '‚òï' },
  { time: '09:00', label: '9:00 AM', icon: 'üìÖ' },
  { time: '10:00', label: '10:00 AM', icon: 'üíº' },
  { time: '11:00', label: '11:00 AM', icon: 'üìä' },
  { time: '12:00', label: '12:00 PM', icon: 'üçΩÔ∏è' },
  { time: '13:00', label: '1:00 PM', icon: 'üìã' },
  { time: '14:00', label: '2:00 PM', icon: 'üë•' },
  { time: '15:00', label: '3:00 PM', icon: 'üè†' },
  { time: '16:00', label: '4:00 PM', icon: 'üìù' },
  { time: '17:00', label: '5:00 PM', icon: 'üéØ' },
  { time: '18:00', label: '6:00 PM', icon: 'üåÜ' }
];

export default function EnhancedEventModal({ 
  event, 
  eventType = 'appointment',
  users = [],
  clients = [],
  properties = [],
  onSave, 
  onClose,
  currentUser
}) {
  const [activeTab, setActiveTab] = useState('details');
  
  // Initialize form data based on event type
  const getInitialFormData = () => {
    const baseData = {
      timezone: 'America/New_York',
      all_day: false,
      location_address: '',
      is_virtual: false,
      virtual_meeting_url: '',
      description: '',
      guest_emails: [],
      guest_permissions: {
        can_modify: false,
        can_invite: false,
        can_see_guests: true
      },
      notifications: [
        { type: 'email', minutes_before: 30 },
        { type: 'email', minutes_before: 10 }
      ],
      availability_status: 'busy',
      visibility: 'default',
      recurrence: 'none',
      recurrence_end: null,
      color: 'blue'
    };

    if (eventType === 'task') {
      return {
        ...baseData,
        title: event?.title || '',
        due_date: event?.due_date || format(new Date(), 'yyyy-MM-dd'),
        due_time: event?.due_time || '09:00',
        due_end_time: event?.due_end_time || '10:00',
        assigned_to: event?.assigned_to || currentUser?.id || '',
        property_id: event?.property_id || '',
        task_type: event?.task_type || 'general',
        priority: event?.priority || 'medium',
        status: event?.status || 'pending',
        color: event?.color || 'cyan',
        ...event
      };
    } else if (eventType === 'open_house') {
      return {
        ...baseData,
        property_id: event?.property_id || '',
        date: event?.date || format(new Date(), 'yyyy-MM-dd'),
        start_time: event?.start_time || '10:00',
        end_time: event?.end_time || '13:00',
        hosting_agent_id: event?.hosting_agent_id || currentUser?.id || '',
        status: event?.status || 'proposed',
        notes: event?.notes || '',
        color: event?.color || 'violet',
        ...event
      };
    } else if (eventType === 'showing') {
      return {
        ...baseData,
        property_id: event?.property_id || '',
        scheduled_date: event?.scheduled_date || format(new Date(), 'yyyy-MM-dd'),
        scheduled_time: event?.scheduled_time || '14:00',
        scheduled_end_time: event?.scheduled_end_time || '14:30',
        showing_agent_id: event?.showing_agent_id || currentUser?.id || '',
        buyer_id: event?.buyer_id || '',
        buyer_name: event?.buyer_name || '',
        buyer_email: event?.buyer_email || '',
        buyer_phone: event?.buyer_phone || '',
        duration_minutes: event?.duration_minutes || 30,
        status: event?.status || 'scheduled',
        notes: event?.notes || '',
        color: event?.color || 'emerald',
        ...event
      };
    } else {
      // appointment
      return {
        ...baseData,
        ...event,
        title: event?.title || '',
        scheduled_date: event?.scheduled_date || format(new Date(), 'yyyy-MM-dd'),
        scheduled_time: event?.scheduled_time || '09:00',
        scheduled_end_time: event?.scheduled_end_time || '10:00',
        duration_minutes: event?.duration_minutes || 60,
        agent_id: event?.agent_id || currentUser?.id || '',
        client_name: event?.client_name || '',
        client_email: event?.client_email || '',
        client_phone: event?.client_phone || '',
        property_id: event?.property_id || '',
        appointment_type: event?.appointment_type || 'client_meeting',
        notes: event?.notes || '',
        color: event?.color || 'pink'
      };
    }
  };

  const [formData, setFormData] = useState(getInitialFormData());
  
  const [guestEmail, setGuestEmail] = useState('');
  const [showTimezonePicker, setShowTimezonePicker] = useState(false);
  const [showNotificationAdd, setShowNotificationAdd] = useState(false);
  const [newNotification, setNewNotification] = useState({ type: 'email', minutes_before: 30 });
  const [isFindingBestTime, setIsFindingBestTime] = useState(false);
  const [suggestedTimes, setSuggestedTimes] = useState([]);
  const [allEvents, setAllEvents] = useState([]);
  const suggestionsRef = React.useRef(null);

  // Fetch all events for conflict detection and time finding
  useEffect(() => {
    const fetchAllEvents = async () => {
      try {
        const [tasks, appointments, showings, openHouses] = await Promise.all([
          base44.entities.Task.list().catch(() => []),
          base44.entities.Appointment.list().catch(() => []),
          base44.entities.Showing.list().catch(() => []),
          base44.entities.OpenHouse.list().catch(() => [])
        ]);
        
        const events = [
          ...tasks.map(t => ({ ...t, type: 'task', date: t.due_date, time: t.due_time || '09:00' })),
          ...appointments.map(a => ({ ...a, type: 'appointment', date: a.scheduled_date, time: a.scheduled_time })),
          ...showings.map(s => ({ ...s, type: 'showing', date: s.scheduled_date, time: s.scheduled_time })),
          ...openHouses.map(o => ({ ...o, type: 'open_house', date: o.date, time: o.start_time }))
        ].filter(e => e.date && e.time);
        
        setAllEvents(events);
      } catch (error) {
        console.error('Error fetching events:', error);
      }
    };
    
    fetchAllEvents();
  }, []);

  const handleFindBestTime = async () => {
    setIsFindingBestTime(true);
    setSuggestedTimes([]);
    
    try {
      const targetDate = eventType === 'task' ? formData.due_date : eventType === 'open_house' ? formData.date : formData.scheduled_date;
      const duration = calculateDuration() || 60;
      
      // Get events for the target date
      const dateEvents = allEvents.filter(e => e.date === targetDate && e.status !== 'cancelled' && e.status !== 'completed');
      
      // AI analysis for best time
      const response = await base44.integrations.Core.InvokeLLM({
        prompt: `Analyze this schedule and suggest the 3 best available time slots for a ${duration}-minute ${eventType}.

Current schedule for ${format(parseISO(targetDate), 'MMMM d, yyyy')}:
${dateEvents.length === 0 ? 'No events scheduled' : dateEvents.map(e => `- ${e.time}: ${e.title || e.type} (${e.duration_minutes || 60} min)`).join('\n')}

Consider:
- Standard business hours (8 AM - 6 PM)
- Avoid lunch time (12 PM - 1 PM) unless necessary
- Buffer time between meetings (15 min)
- Group similar events together
- Prefer morning for important meetings

Return 3 optimal time slots with reasoning.`,
        response_json_schema: {
          type: 'object',
          properties: {
            suggestions: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  start_time: { type: 'string', description: 'HH:MM format' },
                  end_time: { type: 'string', description: 'HH:MM format' },
                  reason: { type: 'string' },
                  score: { type: 'number', description: '1-10 rating' }
                }
              }
            }
          }
        }
      });
      
      setSuggestedTimes(response.suggestions || []);
      toast.success(`Found ${response.suggestions?.length || 0} optimal time slots`);
      
      // Scroll to suggestions after a brief delay to ensure they're rendered
      setTimeout(() => {
        suggestionsRef.current?.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }, 100);
    } catch (error) {
      console.error('Error finding best time:', error);
      toast.error('Failed to analyze schedule');
    } finally {
      setIsFindingBestTime(false);
    }
  };

  const handleSelectSuggestedTime = (suggestion) => {
    if (eventType === 'task') {
      setFormData({
        ...formData,
        due_time: suggestion.start_time,
        due_end_time: suggestion.end_time
      });
    } else if (eventType === 'open_house') {
      setFormData({
        ...formData,
        start_time: suggestion.start_time,
        end_time: suggestion.end_time
      });
    } else {
      setFormData({
        ...formData,
        scheduled_time: suggestion.start_time,
        scheduled_end_time: suggestion.end_time
      });
    }
    setSuggestedTimes([]);
    toast.success('Time applied to event');
  };

  // Auto-calculate end time when start time changes (for new events only)
  useEffect(() => {
    if (!event) {
      let startTimeField, endTimeField, defaultDuration;
      
      if (eventType === 'task') {
        startTimeField = 'due_time';
        endTimeField = 'due_end_time';
        defaultDuration = 60;
      } else if (eventType === 'open_house') {
        startTimeField = 'start_time';
        endTimeField = 'end_time';
        defaultDuration = 180;
      } else if (eventType === 'showing') {
        startTimeField = 'scheduled_time';
        endTimeField = 'scheduled_end_time';
        defaultDuration = 30;
      } else {
        startTimeField = 'scheduled_time';
        endTimeField = 'scheduled_end_time';
        defaultDuration = 60;
      }
      
      const startTime = formData[startTimeField];
      if (startTime) {
        const [hours, minutes] = startTime.split(':');
        const startDate = new Date();
        startDate.setHours(parseInt(hours), parseInt(minutes));
        const endDate = addMinutes(startDate, defaultDuration);
        setFormData(prev => ({
          ...prev,
          [endTimeField]: format(endDate, 'HH:mm')
        }));
      }
    }
  }, [
    event, 
    eventType,
    formData.due_time,
    formData.start_time,
    formData.scheduled_time
  ]);

  const handleAddGuest = () => {
    if (!guestEmail || !guestEmail.includes('@')) {
      toast.error('Please enter a valid email address');
      return;
    }
    
    if (formData.guest_emails.includes(guestEmail)) {
      toast.error('Guest already added');
      return;
    }

    setFormData(prev => ({
      ...prev,
      guest_emails: [...prev.guest_emails, guestEmail]
    }));
    setGuestEmail('');
    toast.success('Guest added');
  };

  const handleRemoveGuest = (email) => {
    setFormData(prev => ({
      ...prev,
      guest_emails: prev.guest_emails.filter(e => e !== email)
    }));
    toast.success('Guest removed');
  };

  const handleAddNotification = () => {
    setFormData(prev => ({
      ...prev,
      notifications: [...prev.notifications, newNotification]
    }));
    setNewNotification({ type: 'email', minutes_before: 30 });
    setShowNotificationAdd(false);
    toast.success('Notification added');
  };

  const handleRemoveNotification = (index) => {
    setFormData(prev => ({
      ...prev,
      notifications: prev.notifications.filter((_, i) => i !== index)
    }));
  };

  const calculateDuration = () => {
    let startTime, endTime;
    
    if (eventType === 'task') {
      if (!formData.due_time || !formData.due_end_time) return 60;
      [startTime, endTime] = [formData.due_time, formData.due_end_time];
    } else if (eventType === 'open_house') {
      if (!formData.start_time || !formData.end_time) return 180;
      [startTime, endTime] = [formData.start_time, formData.end_time];
    } else if (eventType === 'showing') {
      if (!formData.scheduled_time || !formData.scheduled_end_time) return formData.duration_minutes || 30;
      [startTime, endTime] = [formData.scheduled_time, formData.scheduled_end_time];
    } else {
      if (!formData.scheduled_time || !formData.scheduled_end_time) return 60;
      [startTime, endTime] = [formData.scheduled_time, formData.scheduled_end_time];
    }
    
    const [startHours, startMinutes] = startTime.split(':').map(Number);
    const [endHours, endMinutes] = endTime.split(':').map(Number);
    
    const startTotalMinutes = startHours * 60 + startMinutes;
    const endTotalMinutes = endHours * 60 + endMinutes;
    
    return endTotalMinutes - startTotalMinutes;
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    
    // Validation based on event type
    if (eventType === 'task') {
      if (!formData.title?.trim()) {
        toast.error('Please enter a task title');
        return;
      }
      if (!formData.assigned_to) {
        toast.error('Please assign the task to someone');
        return;
      }
    } else if (eventType === 'open_house') {
      if (!formData.property_id) {
        toast.error('Please select a property');
        return;
      }
    } else if (eventType === 'showing') {
      if (!formData.property_id) {
        toast.error('Please select a property');
        return;
      }
      if (!formData.buyer_name && !formData.buyer_id) {
        toast.error('Please enter buyer information');
        return;
      }
    } else {
      // appointment
      if (!formData.title?.trim()) {
        toast.error('Please enter a title');
        return;
      }
    }

    const duration = calculateDuration();
    if (duration <= 0 && !formData.all_day) {
      toast.error('End time must be after start time');
      return;
    }

    // Ensure location_address is properly included in the saved data
    const saveData = {
      ...formData,
      duration_minutes: duration
    };
    
    // Explicitly preserve location_address
    if (formData.location_address) {
      saveData.location_address = formData.location_address;
    }
    
    onSave(saveData);
  };

  const currentTimezone = TIMEZONES.find(tz => tz.value === formData.timezone) || TIMEZONES[0];
  const duration = calculateDuration();

  return (
    <Dialog open={true} onOpenChange={onClose}>
      <DialogContent className="max-w-4xl max-h-[95vh] overflow-hidden flex flex-col p-0 z-[9999]">
        <DialogHeader className="px-6 pt-6 pb-4 border-b">
          <DialogTitle className="text-2xl font-bold flex items-center gap-3">
            <div className="w-10 h-10 rounded-lg bg-gradient-to-br from-blue-500 to-purple-600 flex items-center justify-center text-white shadow-lg">
              <Calendar className="w-5 h-5" />
            </div>
            {event?.id ? 
              `Edit ${eventType === 'task' ? 'Task' : eventType === 'open_house' ? 'Open House' : eventType === 'showing' ? 'Showing' : 'Appointment'}` : 
              `New ${eventType === 'task' ? 'Task' : eventType === 'open_house' ? 'Open House' : eventType === 'showing' ? 'Showing' : 'Appointment'}`
            }
          </DialogTitle>
        </DialogHeader>

        <div className="flex-1 overflow-y-auto px-6">
          <Tabs value={activeTab} onValueChange={setActiveTab} className="w-full">
            <TabsList className="grid w-full grid-cols-4 mb-6">
              <TabsTrigger value="details">Details</TabsTrigger>
              <TabsTrigger value="guests">Guests</TabsTrigger>
              <TabsTrigger value="notifications">Notifications</TabsTrigger>
              <TabsTrigger value="options">Options</TabsTrigger>
            </TabsList>

            <form onSubmit={handleSubmit}>
              {/* DETAILS TAB */}
              <TabsContent value="details" className="space-y-5 mt-0">
                {/* Title - conditional based on event type */}
                <div className="space-y-2">
                  <Label className="text-base font-semibold">
                    {eventType === 'task' ? 'Task Title' : eventType === 'open_house' ? 'Property' : eventType === 'showing' ? 'Property' : 'Event Title'}
                  </Label>
                  {eventType === 'open_house' || eventType === 'showing' ? (
                    <select
                      value={formData.property_id}
                      onChange={(e) => {
                        setFormData({...formData, property_id: e.target.value});
                        const prop = properties.find(p => p.id === e.target.value);
                        if (prop && !formData.title) {
                          setFormData(prev => ({...prev, title: prop.address}));
                        }
                      }}
                      className="w-full h-12 px-4 rounded-lg border-2 border-slate-200 dark:border-slate-700 bg-white dark:bg-slate-900 text-lg"
                      required
                    >
                      <option value="">Select property</option>
                      {properties.map(p => (
                        <option key={p.id} value={p.id}>{p.address}</option>
                      ))}
                    </select>
                  ) : (
                    <Input
                      value={formData.title}
                      onChange={(e) => setFormData({...formData, title: e.target.value})}
                      placeholder={eventType === 'task' ? 'What needs to be done?' : 'Add title'}
                      className="text-lg h-12"
                      required
                    />
                  )}
                </div>

                {/* Task-specific fields */}
                {eventType === 'task' && (
                  <div className="grid grid-cols-2 gap-4">
                    <div className="space-y-2">
                      <Label>Assign To</Label>
                      <select
                        value={formData.assigned_to}
                        onChange={(e) => setFormData({...formData, assigned_to: e.target.value})}
                        className="w-full h-11 px-4 rounded-lg border-2 border-slate-200 dark:border-slate-700 bg-white dark:bg-slate-900"
                        required
                      >
                        <option value="">Select user</option>
                        {users.map(u => (
                          <option key={u.id} value={u.id}>{u.full_name || u.email}</option>
                        ))}
                      </select>
                    </div>
                    <div className="space-y-2">
                      <Label>Priority</Label>
                      <select
                        value={formData.priority}
                        onChange={(e) => setFormData({...formData, priority: e.target.value})}
                        className="w-full h-11 px-4 rounded-lg border-2 border-slate-200 dark:border-slate-700 bg-white dark:bg-slate-900"
                      >
                        <option value="low">Low</option>
                        <option value="medium">Medium</option>
                        <option value="high">High</option>
                        <option value="critical">Critical</option>
                      </select>
                    </div>
                  </div>
                )}

                {/* Showing-specific fields */}
                {eventType === 'showing' && (
                  <div className="space-y-3 bg-blue-50 dark:bg-blue-900/20 p-4 rounded-lg border border-blue-200 dark:border-blue-800">
                    <Label className="text-sm font-semibold">Buyer Information</Label>
                    <Input
                      value={formData.buyer_name}
                      onChange={(e) => setFormData({...formData, buyer_name: e.target.value})}
                      placeholder="Buyer name"
                      required
                    />
                    <div className="grid grid-cols-2 gap-3">
                      <Input
                        type="email"
                        value={formData.buyer_email}
                        onChange={(e) => setFormData({...formData, buyer_email: e.target.value})}
                        placeholder="Email"
                      />
                      <Input
                        type="tel"
                        value={formData.buyer_phone}
                        onChange={(e) => setFormData({...formData, buyer_phone: e.target.value})}
                        placeholder="Phone"
                      />
                    </div>
                  </div>
                )}

                <div className="grid grid-cols-2 gap-4">
                  {/* Date & Time */}
                  <div className="col-span-2 space-y-4">
                    <div className="flex items-center gap-3">
                      <div className="w-10 h-10 rounded-lg bg-blue-100 dark:bg-blue-900/30 flex items-center justify-center">
                        <Calendar className="w-5 h-5 text-blue-600" />
                      </div>
                      <div className="flex-1 space-y-2">
                        <Input
                          type="date"
                          value={eventType === 'task' ? formData.due_date : eventType === 'open_house' ? formData.date : formData.scheduled_date}
                          onChange={(e) => {
                            if (eventType === 'task') {
                              setFormData({...formData, due_date: e.target.value});
                            } else if (eventType === 'open_house') {
                              setFormData({...formData, date: e.target.value});
                            } else {
                              setFormData({...formData, scheduled_date: e.target.value});
                            }
                          }}
                          className="h-11"
                          required
                        />
                      </div>
                    </div>

                    {!formData.all_day && (
                      <div className="flex items-center gap-3">
                        <div className="w-10 h-10 rounded-lg bg-purple-100 dark:bg-purple-900/30 flex items-center justify-center">
                          <Clock className="w-5 h-5 text-purple-600" />
                        </div>
                        <div className="flex-1 flex items-center gap-2">
                          <Input
                            type="time"
                            value={
                              eventType === 'task' ? formData.due_time : 
                              eventType === 'open_house' ? formData.start_time : 
                              formData.scheduled_time
                            }
                            onChange={(e) => {
                              if (eventType === 'task') {
                                setFormData({...formData, due_time: e.target.value});
                              } else if (eventType === 'open_house') {
                                setFormData({...formData, start_time: e.target.value});
                              } else {
                                setFormData({...formData, scheduled_time: e.target.value});
                              }
                            }}
                            className="h-11"
                            required
                          />
                          <span className="text-slate-500 font-medium">to</span>
                          <Input
                            type="time"
                            value={
                              eventType === 'task' ? formData.due_end_time : 
                              eventType === 'open_house' ? formData.end_time : 
                              eventType === 'showing' ? formData.scheduled_end_time :
                              formData.scheduled_end_time
                            }
                            onChange={(e) => {
                              if (eventType === 'task') {
                                setFormData({...formData, due_end_time: e.target.value});
                              } else if (eventType === 'open_house') {
                                setFormData({...formData, end_time: e.target.value});
                              } else if (eventType === 'showing') {
                                setFormData({...formData, scheduled_end_time: e.target.value});
                              } else {
                                setFormData({...formData, scheduled_end_time: e.target.value});
                              }
                            }}
                            className="h-11"
                            required
                          />
                        </div>
                      </div>
                    )}

                    {/* Quick Time Selection */}
                    {!formData.all_day && (
                      <div className="ml-13 pl-1">
                        <p className="text-xs text-slate-500 mb-2">Quick Select Time:</p>
                        <div className="flex flex-wrap gap-1.5">
                          {SUGGESTED_TIMES.map(({ time, label, icon }) => {
                            const currentTime = eventType === 'task' ? formData.due_time : eventType === 'open_house' ? formData.start_time : formData.scheduled_time;
                            return (
                              <button
                                key={time}
                                type="button"
                                onClick={() => {
                                  const [hours, minutes] = time.split(':');
                                  const startDate = new Date();
                                  startDate.setHours(parseInt(hours), parseInt(minutes));
                                  const defaultDuration = eventType === 'task' ? 60 : eventType === 'open_house' ? 180 : eventType === 'showing' ? 30 : 60;
                                  const endDate = addMinutes(startDate, defaultDuration);
                                  
                                  if (eventType === 'task') {
                                    setFormData(prev => ({
                                      ...prev,
                                      due_time: time,
                                      due_end_time: format(endDate, 'HH:mm')
                                    }));
                                  } else if (eventType === 'open_house') {
                                    setFormData(prev => ({
                                      ...prev,
                                      start_time: time,
                                      end_time: format(endDate, 'HH:mm')
                                    }));
                                  } else {
                                    setFormData(prev => ({
                                      ...prev,
                                      scheduled_time: time,
                                      scheduled_end_time: format(endDate, 'HH:mm')
                                    }));
                                  }
                                }}
                                className={`px-2 py-1 text-xs rounded-md border transition-all ${
                                  currentTime === time
                                    ? 'bg-indigo-600 text-white border-indigo-600'
                                    : 'bg-white dark:bg-slate-800 border-slate-200 dark:border-slate-700 hover:border-indigo-400'
                                }`}
                              >
                                {icon} {label}
                              </button>
                            );
                          })}
                        </div>
                      </div>
                    )}

                    {/* Timezone & Duration Display */}
                    <div className="ml-13 space-y-2">
                      <div className="flex items-center gap-2 text-sm text-slate-600 dark:text-slate-400">
                        <Globe className="w-4 h-4" />
                        <button
                          type="button"
                          onClick={() => setShowTimezonePicker(!showTimezonePicker)}
                          className="hover:text-indigo-600 dark:hover:text-indigo-400 flex items-center gap-1"
                        >
                          ({currentTimezone.offset}) {currentTimezone.label}
                          <ChevronDown className="w-3 h-3" />
                        </button>
                      </div>

                      {showTimezonePicker && (
                        <div className="bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-lg shadow-lg p-2 max-h-60 overflow-y-auto">
                          {TIMEZONES.map(tz => (
                            <button
                              key={tz.value}
                              type="button"
                              onClick={() => {
                                setFormData({...formData, timezone: tz.value});
                                setShowTimezonePicker(false);
                              }}
                              className={`w-full text-left px-3 py-2 rounded-md text-sm hover:bg-slate-100 dark:hover:bg-slate-700 ${
                                formData.timezone === tz.value ? 'bg-indigo-100 dark:bg-indigo-900/30 font-semibold' : ''
                              }`}
                            >
                              ({tz.offset}) {tz.label}
                            </button>
                          ))}
                        </div>
                      )}

                      {!formData.all_day && duration > 0 && (
                        <div className="text-sm text-slate-600 dark:text-slate-400">
                          Duration: <span className="font-semibold text-slate-900 dark:text-white">{duration} minutes</span>
                          {duration >= 60 && <span className="text-xs ml-2">({Math.floor(duration / 60)}h {duration % 60}m)</span>}
                        </div>
                      )}
                    </div>

                    {/* All Day Toggle */}
                    <div className="ml-13 flex items-center gap-2">
                      <Switch
                        id="all_day"
                        checked={formData.all_day}
                        onCheckedChange={(checked) => setFormData({...formData, all_day: checked})}
                      />
                      <Label htmlFor="all_day" className="cursor-pointer">All day event</Label>
                    </div>
                  </div>
                </div>

                <Separator />

                {/* Location */}
                <div className="space-y-3">
                  <div className="flex items-center justify-between">
                    <Label className="text-base font-semibold">Location</Label>
                    <div className="flex items-center gap-2">
                      <Video className="w-4 h-4 text-slate-500" />
                      <Switch
                        id="is_virtual"
                        checked={formData.is_virtual}
                        onCheckedChange={(checked) => setFormData({...formData, is_virtual: checked})}
                      />
                      <Label htmlFor="is_virtual" className="text-sm cursor-pointer">Virtual</Label>
                    </div>
                  </div>

                  {formData.is_virtual ? (
                    <div className="space-y-2">
                      <Input
                        value={formData.virtual_meeting_url}
                        onChange={(e) => setFormData({...formData, virtual_meeting_url: e.target.value})}
                        placeholder="Add Google Meet, Zoom, or Teams link"
                        className="h-11"
                      />
                      <Button type="button" variant="outline" size="sm" className="w-full">
                        <Video className="w-4 h-4 mr-2" />
                        Generate Zoom Link (Coming Soon)
                      </Button>
                    </div>
                  ) : (
                    <div className="relative">
                      <MapPin className="w-4 h-4 absolute left-3 top-3.5 text-slate-400" />
                      <Input
                        value={formData.location_address}
                        onChange={(e) => setFormData({...formData, location_address: e.target.value})}
                        placeholder="Add location or meeting room"
                        className="pl-10 h-11"
                      />
                    </div>
                  )}
                </div>

                {/* Description */}
                <div className="space-y-2">
                  <Label className="text-base font-semibold">Description</Label>
                  <Textarea
                    value={formData.description}
                    onChange={(e) => setFormData({...formData, description: e.target.value})}
                    placeholder="Add event details, agenda, or notes..."
                    className="min-h-24 resize-none"
                  />
                </div>

                {/* Color Picker */}
                <div className="space-y-2">
                  <Label className="text-sm font-medium text-slate-600">Event Color</Label>
                  <div className="flex flex-wrap gap-2">
                    {[
                      { value: 'blue', bg: 'bg-blue-500', label: 'Blue' },
                      { value: 'purple', bg: 'bg-purple-500', label: 'Purple' },
                      { value: 'pink', bg: 'bg-pink-500', label: 'Pink' },
                      { value: 'red', bg: 'bg-red-500', label: 'Red' },
                      { value: 'orange', bg: 'bg-orange-500', label: 'Orange' },
                      { value: 'amber', bg: 'bg-amber-500', label: 'Amber' },
                      { value: 'green', bg: 'bg-green-500', label: 'Green' },
                      { value: 'emerald', bg: 'bg-emerald-500', label: 'Emerald' },
                      { value: 'cyan', bg: 'bg-cyan-500', label: 'Cyan' },
                      { value: 'slate', bg: 'bg-slate-500', label: 'Slate' }
                    ].map(color => (
                      <button
                        key={color.value}
                        type="button"
                        onClick={() => setFormData({...formData, color: color.value})}
                        className={`flex items-center gap-2 px-3 py-1.5 rounded-lg border-2 transition-all ${
                          formData.color === color.value
                            ? 'border-slate-900 dark:border-white scale-105'
                            : 'border-slate-200 dark:border-slate-700 hover:border-slate-400'
                        }`}
                      >
                        <div className={`w-4 h-4 rounded ${color.bg}`} />
                      </button>
                    ))}
                  </div>
                </div>
              </TabsContent>

              {/* GUESTS TAB */}
              <TabsContent value="guests" className="space-y-5 mt-0">
                <div className="space-y-3">
                  <Label className="text-base font-semibold">Add Guests</Label>
                  <div className="flex gap-2">
                    <div className="relative flex-1">
                      <Mail className="w-4 h-4 absolute left-3 top-3.5 text-slate-400" />
                      <Input
                        value={guestEmail}
                        onChange={(e) => setGuestEmail(e.target.value)}
                        onKeyPress={(e) => {
                          if (e.key === 'Enter') {
                            e.preventDefault();
                            handleAddGuest();
                          }
                        }}
                        placeholder="Enter email address"
                        className="pl-10 h-11"
                      />
                    </div>
                    <Button type="button" onClick={handleAddGuest} size="lg">
                      <UserPlus className="w-4 h-4 mr-2" />
                      Add
                    </Button>
                  </div>

                  {/* Guest List */}
                  {formData.guest_emails.length > 0 && (
                    <div className="space-y-2">
                      <p className="text-sm text-slate-600 dark:text-slate-400">
                        {formData.guest_emails.length} guest{formData.guest_emails.length !== 1 ? 's' : ''}
                      </p>
                      <div className="space-y-2 max-h-64 overflow-y-auto border border-slate-200 dark:border-slate-700 rounded-lg p-3">
                        {formData.guest_emails.map((email, idx) => (
                          <div key={idx} className="flex items-center justify-between p-2 bg-slate-50 dark:bg-slate-800 rounded-lg">
                            <div className="flex items-center gap-3">
                              <div className="w-8 h-8 rounded-full bg-gradient-to-br from-indigo-500 to-purple-600 flex items-center justify-center text-white text-sm font-semibold">
                                {email.charAt(0).toUpperCase()}
                              </div>
                              <span className="text-sm font-medium">{email}</span>
                            </div>
                            <Button
                              type="button"
                              variant="ghost"
                              size="icon"
                              onClick={() => handleRemoveGuest(email)}
                              className="h-8 w-8 text-red-600 hover:text-red-700 hover:bg-red-50"
                            >
                              <X className="w-4 h-4" />
                            </Button>
                          </div>
                        ))}
                      </div>
                    </div>
                  )}
                </div>

                <Separator />

                {/* Guest Permissions */}
                <div className="space-y-3">
                  <Label className="text-base font-semibold flex items-center gap-2">
                    <Settings className="w-4 h-4" />
                    Guest Permissions
                  </Label>
                  <div className="space-y-3 bg-slate-50 dark:bg-slate-800/50 p-4 rounded-lg">
                    <div className="flex items-center justify-between">
                      <div>
                        <Label className="text-sm font-medium">Modify event</Label>
                        <p className="text-xs text-slate-500">Guests can change event details</p>
                      </div>
                      <Switch
                        checked={formData.guest_permissions.can_modify}
                        onCheckedChange={(checked) => setFormData({
                          ...formData,
                          guest_permissions: {...formData.guest_permissions, can_modify: checked}
                        })}
                      />
                    </div>
                    <div className="flex items-center justify-between">
                      <div>
                        <Label className="text-sm font-medium">Invite others</Label>
                        <p className="text-xs text-slate-500">Guests can add more people</p>
                      </div>
                      <Switch
                        checked={formData.guest_permissions.can_invite}
                        onCheckedChange={(checked) => setFormData({
                          ...formData,
                          guest_permissions: {...formData.guest_permissions, can_invite: checked}
                        })}
                      />
                    </div>
                    <div className="flex items-center justify-between">
                      <div>
                        <Label className="text-sm font-medium">See guest list</Label>
                        <p className="text-xs text-slate-500">Guests can view other attendees</p>
                      </div>
                      <Switch
                        checked={formData.guest_permissions.can_see_guests}
                        onCheckedChange={(checked) => setFormData({
                          ...formData,
                          guest_permissions: {...formData.guest_permissions, can_see_guests: checked}
                        })}
                      />
                    </div>
                  </div>
                </div>
              </TabsContent>

              {/* NOTIFICATIONS TAB */}
              <TabsContent value="notifications" className="space-y-5 mt-0">
                <div className="space-y-3">
                  <div className="flex items-center justify-between">
                    <Label className="text-base font-semibold">Event Reminders</Label>
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={() => setShowNotificationAdd(!showNotificationAdd)}
                    >
                      <Plus className="w-4 h-4 mr-2" />
                      Add Reminder
                    </Button>
                  </div>

                  {showNotificationAdd && (
                    <div className="bg-slate-50 dark:bg-slate-800 p-4 rounded-lg border border-slate-200 dark:border-slate-700 space-y-3">
                      <div className="grid grid-cols-2 gap-3">
                        <div className="space-y-2">
                          <Label className="text-sm">Method</Label>
                          <select
                            value={newNotification.type}
                            onChange={(e) => setNewNotification({...newNotification, type: e.target.value})}
                            className="w-full h-10 px-3 rounded-lg border border-slate-200 dark:border-slate-700 bg-white dark:bg-slate-900"
                          >
                            <option value="email">Email</option>
                            <option value="sms">SMS (Coming Soon)</option>
                            <option value="push">Push Notification</option>
                          </select>
                        </div>
                        <div className="space-y-2">
                          <Label className="text-sm">Time Before</Label>
                          <select
                            value={newNotification.minutes_before}
                            onChange={(e) => setNewNotification({...newNotification, minutes_before: parseInt(e.target.value)})}
                            className="w-full h-10 px-3 rounded-lg border border-slate-200 dark:border-slate-700 bg-white dark:bg-slate-900"
                          >
                            {NOTIFICATION_TIMES.map(n => (
                              <option key={n.value} value={n.value}>{n.label}</option>
                            ))}
                          </select>
                        </div>
                      </div>
                      <div className="flex justify-end gap-2">
                        <Button type="button" variant="ghost" size="sm" onClick={() => setShowNotificationAdd(false)}>
                          Cancel
                        </Button>
                        <Button type="button" size="sm" onClick={handleAddNotification}>
                          Add Reminder
                        </Button>
                      </div>
                    </div>
                  )}

                  {/* Notification List */}
                  {formData.notifications.length > 0 ? (
                    <div className="space-y-2">
                      {formData.notifications.map((notif, idx) => (
                        <div key={idx} className="flex items-center justify-between p-3 bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-lg">
                          <div className="flex items-center gap-3">
                            <div className="w-8 h-8 rounded-lg bg-blue-100 dark:bg-blue-900/30 flex items-center justify-center">
                              {notif.type === 'email' ? <Mail className="w-4 h-4 text-blue-600" /> : <Bell className="w-4 h-4 text-green-600" />}
                            </div>
                            <div>
                              <p className="text-sm font-medium capitalize">{notif.type}</p>
                              <p className="text-xs text-slate-500">
                                {NOTIFICATION_TIMES.find(n => n.value === notif.minutes_before)?.label || `${notif.minutes_before} minutes before`}
                              </p>
                            </div>
                          </div>
                          <Button
                            type="button"
                            variant="ghost"
                            size="icon"
                            onClick={() => handleRemoveNotification(idx)}
                            className="h-8 w-8 text-red-600 hover:text-red-700"
                          >
                            <X className="w-4 h-4" />
                          </Button>
                        </div>
                      ))}
                    </div>
                  ) : (
                    <div className="text-center py-8 text-slate-500">
                      <Bell className="w-12 h-12 mx-auto mb-3 opacity-30" />
                      <p className="text-sm">No reminders set</p>
                    </div>
                  )}
                </div>
              </TabsContent>

              {/* OPTIONS TAB */}
              <TabsContent value="options" className="space-y-5 mt-0">
                {/* Recurrence */}
                <div className="space-y-3">
                  <Label className="text-base font-semibold">Recurrence</Label>
                  <select
                    value={formData.recurrence}
                    onChange={(e) => setFormData({...formData, recurrence: e.target.value})}
                    className="w-full h-11 px-4 rounded-lg border border-slate-200 dark:border-slate-700 bg-white dark:bg-slate-900"
                  >
                    <option value="none">Does not repeat</option>
                    <option value="daily">Daily</option>
                    <option value="weekly">Weekly</option>
                    <option value="monthly">Monthly</option>
                    <option value="yearly">Yearly</option>
                    <option value="weekdays">Every weekday (Mon-Fri)</option>
                    <option value="custom">Custom...</option>
                  </select>

                  {formData.recurrence !== 'none' && (
                    <div className="space-y-2">
                      <Label className="text-sm">Ends On</Label>
                      <Input
                        type="date"
                        value={formData.recurrence_end}
                        onChange={(e) => setFormData({...formData, recurrence_end: e.target.value})}
                        min={formData.scheduled_date}
                        className="h-11"
                      />
                    </div>
                  )}
                </div>

                <Separator />

                {/* Availability Status */}
                <div className="space-y-3">
                  <Label className="text-base font-semibold">Show As</Label>
                  <div className="grid grid-cols-2 gap-2">
                    {[
                      { value: 'busy', label: 'Busy', color: 'bg-red-500', desc: 'Block this time' },
                      { value: 'free', label: 'Free', color: 'bg-green-500', desc: 'Available during event' },
                      { value: 'tentative', label: 'Tentative', color: 'bg-amber-500', desc: 'Maybe attending' },
                      { value: 'out_of_office', label: 'Out of Office', color: 'bg-purple-500', desc: 'Not in office' }
                    ].map(status => (
                      <button
                        key={status.value}
                        type="button"
                        onClick={() => setFormData({...formData, availability_status: status.value})}
                        className={`p-3 rounded-lg border-2 text-left transition-all ${
                          formData.availability_status === status.value
                            ? 'border-slate-900 dark:border-white bg-slate-50 dark:bg-slate-800'
                            : 'border-slate-200 dark:border-slate-700 hover:border-slate-400'
                        }`}
                      >
                        <div className="flex items-center gap-2 mb-1">
                          <div className={`w-3 h-3 rounded-full ${status.color}`} />
                          <span className="font-semibold text-sm">{status.label}</span>
                        </div>
                        <p className="text-xs text-slate-500">{status.desc}</p>
                      </button>
                    ))}
                  </div>
                </div>

                <Separator />

                {/* Visibility */}
                <div className="space-y-3">
                  <Label className="text-base font-semibold">Visibility</Label>
                  <div className="grid grid-cols-3 gap-2">
                    {[
                      { value: 'default', icon: Eye, label: 'Default', desc: 'Visible to team' },
                      { value: 'public', icon: Globe, label: 'Public', desc: 'Anyone can see' },
                      { value: 'private', icon: Lock, label: 'Private', desc: 'Only you' }
                    ].map(vis => (
                      <button
                        key={vis.value}
                        type="button"
                        onClick={() => setFormData({...formData, visibility: vis.value})}
                        className={`p-3 rounded-lg border-2 transition-all ${
                          formData.visibility === vis.value
                            ? 'border-indigo-600 bg-indigo-50 dark:bg-indigo-900/20'
                            : 'border-slate-200 dark:border-slate-700 hover:border-slate-400'
                        }`}
                      >
                        <vis.icon className={`w-5 h-5 mx-auto mb-1 ${
                          formData.visibility === vis.value ? 'text-indigo-600' : 'text-slate-400'
                        }`} />
                        <p className="text-xs font-semibold">{vis.label}</p>
                        <p className="text-xs text-slate-500 mt-0.5">{vis.desc}</p>
                      </button>
                    ))}
                  </div>
                </div>

                {/* Smart Features */}
                <div className="bg-gradient-to-br from-indigo-50 to-purple-50 dark:from-indigo-900/20 dark:to-purple-900/20 p-4 rounded-lg border border-indigo-200 dark:border-indigo-800">
                  <div className="flex items-start gap-3">
                    <div className="w-10 h-10 rounded-full bg-gradient-to-br from-indigo-500 to-purple-600 flex items-center justify-center flex-shrink-0">
                      <Zap className="w-5 h-5 text-white" />
                    </div>
                    <div className="flex-1">
                      <h4 className="font-semibold text-slate-900 dark:text-white mb-2">Smart Features</h4>
                      <div className="space-y-2 text-sm text-slate-600 dark:text-slate-400 mb-3">
                        <p>‚ú® Intelligent time suggestions based on your schedule</p>
                        <p>üìç Automatic travel time calculation</p>
                        <p>üîî Smart departure reminders</p>
                        <p>üë• Conflict detection with existing events</p>
                      </div>
                      <Button 
                        type="button" 
                        variant="outline" 
                        size="sm" 
                        onClick={handleFindBestTime}
                        disabled={isFindingBestTime}
                        className="bg-white dark:bg-slate-800"
                      >
                        {isFindingBestTime ? (
                          <>
                            <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                            Analyzing Schedule...
                          </>
                        ) : (
                          <>
                            <Zap className="w-4 h-4 mr-2" />
                            Find Best Time
                          </>
                        )}
                      </Button>

                      {/* Intelligent Suggested Times */}
                      {suggestedTimes.length > 0 && (
                        <div ref={suggestionsRef} className="mt-4 space-y-2">
                          <p className="text-xs font-semibold text-indigo-700 dark:text-indigo-300">Intelligent Recommendations:</p>
                          {suggestedTimes.map((suggestion, idx) => (
                            <button
                              key={idx}
                              type="button"
                              onClick={() => handleSelectSuggestedTime(suggestion)}
                              className="w-full text-left p-3 bg-white dark:bg-slate-800 rounded-lg border-2 border-indigo-200 dark:border-indigo-800 hover:border-indigo-400 dark:hover:border-indigo-600 transition-all group"
                            >
                              <div className="flex items-start justify-between gap-2">
                                <div className="flex-1">
                                  <div className="flex items-center gap-2 mb-1">
                                    <Clock className="w-4 h-4 text-indigo-600" />
                                    <span className="font-semibold text-slate-900 dark:text-white">
                                      {suggestion.start_time} - {suggestion.end_time}
                                    </span>
                                    <Badge className="bg-indigo-100 text-indigo-700 dark:bg-indigo-900/30 dark:text-indigo-300">
                                      Score: {suggestion.score}/10
                                    </Badge>
                                  </div>
                                  <p className="text-xs text-slate-600 dark:text-slate-400">{suggestion.reason}</p>
                                </div>
                                <div className="opacity-0 group-hover:opacity-100 transition-opacity">
                                  <Badge variant="outline" className="bg-indigo-600 text-white border-indigo-600">
                                    Select
                                  </Badge>
                                </div>
                              </div>
                            </button>
                          ))}
                        </div>
                      )}
                    </div>
                  </div>
                </div>
              </TabsContent>
            </form>
          </Tabs>
        </div>

        {/* Footer Actions */}
        <div className="px-6 py-4 border-t bg-slate-50 dark:bg-slate-900 flex items-center justify-between gap-3">
          <div className="flex items-center gap-2">
            {event?.id && (
              <Button type="button" variant="destructive" size="sm">
                Delete
              </Button>
            )}
          </div>
          <div className="flex items-center gap-2">
            <Button type="button" variant="outline" onClick={onClose}>
              Cancel
            </Button>
            <Button 
              onClick={(e) => {
                const form = e.currentTarget.closest('form') || document.querySelector('form');
                if (form) {
                  form.requestSubmit();
                } else {
                  handleSubmit(e);
                }
              }}
              className="bg-gradient-to-r from-indigo-600 to-purple-600 hover:from-indigo-700 hover:to-purple-700 shadow-lg"
            >
              {event?.id ? 'Save Changes' : 'Create Event'}
            </Button>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}
import { useEffect, useRef, useState } from 'react';
import { parseISO, differenceInMinutes, isToday, format } from 'date-fns';
import { toast } from 'sonner';

export default function EventNotificationSound({ events, user }) {
  const [notifiedEvents, setNotifiedEvents] = useState(new Set());
  const audioRef = useRef(null);

  useEffect(() => {
    // Create audio element for notification sound
    if (!audioRef.current) {
      audioRef.current = new Audio();
      // Google Calendar-style notification sound (using a simple beep)
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.value = 800; // Frequency in Hz
      oscillator.type = 'sine';
      
      gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
      
      // Store audio context for later use
      audioRef.current.audioContext = audioContext;
    }

    // Check for upcoming events every 30 seconds
    const checkEvents = () => {
      const now = new Date();
      
      events.forEach(event => {
        // Skip if already notified
        if (notifiedEvents.has(event.id)) return;
        
        // Skip holidays
        if (event.type === 'holiday') return;
        
        // Only check today's events
        const eventDate = parseISO(event.date);
        if (!isToday(eventDate)) return;
        
        // Parse event time
        const [hours, minutes] = (event.time || '09:00').split(':');
        const eventDateTime = new Date(eventDate);
        eventDateTime.setHours(parseInt(hours), parseInt(minutes), 0, 0);
        
        // Check if event is due (within 1 minute)
        const minutesUntil = differenceInMinutes(eventDateTime, now);
        
        if (minutesUntil === 0) {
          // Play notification sound
          playNotificationSound();
          
          // Show toast notification
          const eventTypeLabel = {
            task: 'üìã Task',
            appointment: 'üìÖ Appointment',
            showing: 'üè† Showing',
            open_house: 'üè° Open House'
          }[event.type] || 'Event';
          
          toast.info(`${eventTypeLabel} starting now: ${event.title}`, {
            duration: 10000,
            action: {
              label: 'View',
              onClick: () => {
                // Could navigate to event details here
              }
            }
          });
          
          // Mark as notified
          setNotifiedEvents(prev => new Set(prev).add(event.id));
        }
      });
    };

    const playNotificationSound = () => {
      try {
        const audioContext = audioRef.current?.audioContext;
        if (audioContext) {
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          
          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);
          
          // Google Calendar-like notification sound
          oscillator.frequency.value = 800;
          oscillator.type = 'sine';
          
          gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
          
          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext.currentTime + 0.5);
        }
      } catch (error) {
        console.error('Error playing notification sound:', error);
      }
    };

    // Initial check
    checkEvents();
    
    // Check every 30 seconds
    const interval = setInterval(checkEvents, 30000);
    
    return () => clearInterval(interval);
  }, [events, notifiedEvents]);

  // Reset notified events at midnight
  useEffect(() => {
    const now = new Date();
    const tomorrow = new Date(now);
    tomorrow.setDate(tomorrow.getDate() + 1);
    tomorrow.setHours(0, 0, 0, 0);
    
    const msUntilMidnight = tomorrow.getTime() - now.getTime();
    
    const timeout = setTimeout(() => {
      setNotifiedEvents(new Set());
    }, msUntilMidnight);
    
    return () => clearTimeout(timeout);
  }, []);

  // This component doesn't render anything
  return null;
}
import React, { useState } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { base44 } from '@/api/base44Client';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Badge } from '@/components/ui/badge';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { toast } from 'sonner';
import { Plus, Trash2, Copy, Edit, Sparkles, Calendar, CheckSquare, Eye, Home } from 'lucide-react';

export default function EventTemplateManager({ isOpen, onClose, onSelectTemplate }) {
  const queryClient = useQueryClient();
  const [showCreateForm, setShowCreateForm] = useState(false);
  const [editingTemplate, setEditingTemplate] = useState(null);
  const [formData, setFormData] = useState({
    name: '',
    description: '',
    event_type: 'appointment',
    default_title: '',
    default_duration_minutes: 60,
    default_location: '',
    default_notes: '',
    appointment_type: '',
    is_recurring: false,
    recurrence_pattern: 'weekly',
    recurrence_days: '',
    is_virtual: false,
    video_link_template: '',
    color: 'pink',
    is_shared: false
  });

  const { data: user } = useQuery({
    queryKey: ['user'],
    queryFn: () => base44.auth.me()
  });

  const { data: templates = [] } = useQuery({
    queryKey: ['eventTemplates'],
    queryFn: async () => {
      const [myTemplates, sharedTemplates] = await Promise.all([
        base44.entities.EventTemplate.filter({ created_by_id: user.id }),
        base44.entities.EventTemplate.filter({ is_shared: true })
      ]);
      return [...myTemplates, ...sharedTemplates].filter((t, i, arr) => 
        arr.findIndex(t2 => t2.id === t.id) === i
      );
    },
    enabled: !!user?.id
  });

  const createTemplateMutation = useMutation({
    mutationFn: (data) => base44.entities.EventTemplate.create({
      ...data,
      created_by_id: user.id
    }),
    onSuccess: () => {
      queryClient.invalidateQueries(['eventTemplates']);
      toast.success('Template created!');
      setShowCreateForm(false);
      resetForm();
    }
  });

  const updateTemplateMutation = useMutation({
    mutationFn: ({ id, data }) => base44.entities.EventTemplate.update(id, data),
    onSuccess: () => {
      queryClient.invalidateQueries(['eventTemplates']);
      toast.success('Template updated!');
      setEditingTemplate(null);
      resetForm();
    }
  });

  const deleteTemplateMutation = useMutation({
    mutationFn: (id) => base44.entities.EventTemplate.delete(id),
    onSuccess: () => {
      queryClient.invalidateQueries(['eventTemplates']);
      toast.success('Template deleted');
    }
  });

  const resetForm = () => {
    setFormData({
      name: '',
      description: '',
      event_type: 'appointment',
      default_title: '',
      default_duration_minutes: 60,
      default_location: '',
      default_notes: '',
      appointment_type: '',
      is_recurring: false,
      recurrence_pattern: 'weekly',
      recurrence_days: '',
      is_virtual: false,
      video_link_template: '',
      color: 'pink',
      is_shared: false
    });
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    if (editingTemplate) {
      updateTemplateMutation.mutate({ id: editingTemplate.id, data: formData });
    } else {
      createTemplateMutation.mutate(formData);
    }
  };

  const handleEdit = (template) => {
    setEditingTemplate(template);
    setFormData(template);
    setShowCreateForm(true);
  };

  const handleUseTemplate = (template) => {
    onSelectTemplate(template);
    onClose();
  };

  const eventTypeIcons = {
    appointment: Calendar,
    task: CheckSquare,
    showing: Eye,
    open_house: Home
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-4xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <Sparkles className="w-5 h-5 text-purple-600" />
            Event Templates
          </DialogTitle>
        </DialogHeader>

        {!showCreateForm ? (
          <div className="space-y-4">
            <Button 
              onClick={() => setShowCreateForm(true)}
              className="w-full"
            >
              <Plus className="w-4 h-4 mr-2" />
              Create New Template
            </Button>

            <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
              {templates.map((template) => {
                const Icon = eventTypeIcons[template.event_type];
                return (
                  <div
                    key={template.id}
                    className="border border-slate-200 rounded-lg p-4 hover:shadow-lg transition-all"
                  >
                    <div className="flex items-start justify-between mb-2">
                      <div className="flex items-center gap-2">
                        <div className={`w-8 h-8 rounded-lg bg-${template.color}-500 flex items-center justify-center text-white`}>
                          {Icon && <Icon className="w-4 h-4" />}
                        </div>
                        <div>
                          <h3 className="font-semibold text-slate-900">{template.name}</h3>
                          {template.is_shared && (
                            <Badge variant="outline" className="text-xs mt-1">
                              Shared
                            </Badge>
                          )}
                        </div>
                      </div>
                    </div>

                    {template.description && (
                      <p className="text-xs text-slate-600 mb-3">{template.description}</p>
                    )}

                    <div className="flex flex-wrap gap-2 mb-3 text-xs">
                      <Badge variant="secondary">{template.event_type}</Badge>
                      {template.default_duration_minutes && (
                        <Badge variant="outline">{template.default_duration_minutes} min</Badge>
                      )}
                      {template.is_recurring && (
                        <Badge variant="outline">üîÑ Recurring</Badge>
                      )}
                      {template.is_virtual && (
                        <Badge variant="outline">üíª Virtual</Badge>
                      )}
                    </div>

                    <div className="flex gap-2">
                      <Button
                        size="sm"
                        onClick={() => handleUseTemplate(template)}
                        className="flex-1"
                      >
                        <Copy className="w-3 h-3 mr-1" />
                        Use
                      </Button>
                      {template.created_by_id === user?.id && (
                        <>
                          <Button
                            size="sm"
                            variant="outline"
                            onClick={() => handleEdit(template)}
                          >
                            <Edit className="w-3 h-3" />
                          </Button>
                          <Button
                            size="sm"
                            variant="outline"
                            onClick={() => deleteTemplateMutation.mutate(template.id)}
                          >
                            <Trash2 className="w-3 h-3 text-red-600" />
                          </Button>
                        </>
                      )}
                    </div>
                  </div>
                );
              })}
            </div>

            {templates.length === 0 && (
              <div className="text-center py-12">
                <Sparkles className="w-12 h-12 text-slate-300 mx-auto mb-3" />
                <p className="text-slate-600">No templates yet. Create your first one!</p>
              </div>
            )}
          </div>
        ) : (
          <form onSubmit={handleSubmit} className="space-y-4">
            <div className="grid grid-cols-2 gap-4">
              <Input
                placeholder="Template Name"
                value={formData.name}
                onChange={(e) => setFormData({ ...formData, name: e.target.value })}
                required
              />
              <Select
                value={formData.event_type}
                onValueChange={(value) => setFormData({ ...formData, event_type: value })}
              >
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="appointment">Appointment</SelectItem>
                  <SelectItem value="task">Task</SelectItem>
                  <SelectItem value="showing">Showing</SelectItem>
                  <SelectItem value="open_house">Open House</SelectItem>
                </SelectContent>
              </Select>
            </div>

            <Textarea
              placeholder="Description"
              value={formData.description}
              onChange={(e) => setFormData({ ...formData, description: e.target.value })}
              rows={2}
            />

            <div className="grid grid-cols-2 gap-4">
              <Input
                placeholder="Default Title"
                value={formData.default_title}
                onChange={(e) => setFormData({ ...formData, default_title: e.target.value })}
              />
              <Input
                type="number"
                placeholder="Duration (minutes)"
                value={formData.default_duration_minutes}
                onChange={(e) => setFormData({ ...formData, default_duration_minutes: parseInt(e.target.value) })}
              />
            </div>

            <Input
              placeholder="Default Location"
              value={formData.default_location}
              onChange={(e) => setFormData({ ...formData, default_location: e.target.value })}
            />

            <Textarea
              placeholder="Default Notes"
              value={formData.default_notes}
              onChange={(e) => setFormData({ ...formData, default_notes: e.target.value })}
              rows={3}
            />

            {formData.event_type === 'appointment' && (
              <Input
                placeholder="Appointment Type (e.g., buyer_consultation)"
                value={formData.appointment_type}
                onChange={(e) => setFormData({ ...formData, appointment_type: e.target.value })}
              />
            )}

            <div className="flex items-center gap-4">
              <label className="flex items-center gap-2 cursor-pointer">
                <input
                  type="checkbox"
                  checked={formData.is_virtual}
                  onChange={(e) => setFormData({ ...formData, is_virtual: e.target.checked })}
                  className="rounded"
                />
                <span className="text-sm">Virtual Event</span>
              </label>

              <label className="flex items-center gap-2 cursor-pointer">
                <input
                  type="checkbox"
                  checked={formData.is_shared}
                  onChange={(e) => setFormData({ ...formData, is_shared: e.target.checked })}
                  className="rounded"
                />
                <span className="text-sm">Share with Team</span>
              </label>

              <label className="flex items-center gap-2 cursor-pointer">
                <input
                  type="checkbox"
                  checked={formData.is_recurring}
                  onChange={(e) => setFormData({ ...formData, is_recurring: e.target.checked })}
                  className="rounded"
                />
                <span className="text-sm">Recurring</span>
              </label>
            </div>

            {formData.is_recurring && (
              <div className="grid grid-cols-2 gap-4">
                <Select
                  value={formData.recurrence_pattern}
                  onValueChange={(value) => setFormData({ ...formData, recurrence_pattern: value })}
                >
                  <SelectTrigger>
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="daily">Daily</SelectItem>
                    <SelectItem value="weekly">Weekly</SelectItem>
                    <SelectItem value="monthly">Monthly</SelectItem>
                  </SelectContent>
                </Select>
                {formData.recurrence_pattern === 'weekly' && (
                  <Input
                    placeholder="Days (mon,wed,fri)"
                    value={formData.recurrence_days}
                    onChange={(e) => setFormData({ ...formData, recurrence_days: e.target.value })}
                  />
                )}
              </div>
            )}

            <Select
              value={formData.color}
              onValueChange={(value) => setFormData({ ...formData, color: value })}
            >
              <SelectTrigger>
                <SelectValue placeholder="Color" />
              </SelectTrigger>
              <SelectContent>
                {['pink', 'blue', 'purple', 'green', 'orange', 'red', 'cyan', 'amber'].map(color => (
                  <SelectItem key={color} value={color}>
                    <div className="flex items-center gap-2">
                      <div className={`w-4 h-4 rounded bg-${color}-500`}></div>
                      {color.charAt(0).toUpperCase() + color.slice(1)}
                    </div>
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>

            <div className="flex gap-3 pt-4">
              <Button
                type="button"
                variant="outline"
                onClick={() => {
                  setShowCreateForm(false);
                  setEditingTemplate(null);
                  resetForm();
                }}
                className="flex-1"
              >
                Cancel
              </Button>
              <Button type="submit" className="flex-1">
                {editingTemplate ? 'Update' : 'Create'} Template
              </Button>
            </div>
          </form>
        )}
      </DialogContent>
    </Dialog>
  );
}

import React, { useState, useRef, useCallback, useEffect } from 'react';
import { base44 } from "@/api/base44Client";
import { toast } from "sonner";
import {
    DropdownMenu,
    DropdownMenuContent,
    DropdownMenuItem,
    DropdownMenuLabel,
    DropdownMenuSeparator,
    DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Button } from "@/components/ui/button";
import { Send, Clock, Loader2 } from "lucide-react";

// Assuming 'user' prop in the original component is now 'currentUser' based on the alarm logic.
export default function LateNotificationSender({ appointment, currentUser, onNotificationSent }) {
    const [isSending, setIsSending] = useState(false);
    const audioRef = useRef(null);
    const isPlayingRef = useRef(false);

    const playAlarm = useCallback((sound) => {
        if (!currentUser?.alarm_enabled) return;
        
        // Prevent multiple simultaneous plays
        if (isPlayingRef.current) {
            return;
        }

        const soundMap = {
            beep: 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIGGS57OypUhIRTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUhIOTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUhIOTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUhIOTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUhIOTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUhIOTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUhIOTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUg==',
            chime: 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIGGS57OypUhIRTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUhIOTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUhIOTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUhIOTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUhIOTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUhIOTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUhIOTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUhIOTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUg==',
            bell: 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIGGS57OypUhIRTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUhIOTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUhIOTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUhIOTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUhIOTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUhIOTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUhIOTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUhIOTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUg==',
            alert: 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIGGS57OypUhIRTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUhIOTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUhIOTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUhIOTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUhIOTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUhIOTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUhIOTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUhIOTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUg==',
            urgent: 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIGGS57OypUhIRTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUhIOTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUhIOTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUhIOTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUhIOTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUhIOTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUhIOTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUhIOTKXh7qpiKAU7jdXyzXkqBSh+zPLaizsKGGS56+ypUg=='
        };

        const soundUrl = soundMap[sound] || soundMap.beep;

        try {
            if (audioRef.current) {
                audioRef.current.pause();
                audioRef.current.currentTime = 0;
            }

            const audio = new Audio(soundUrl);
            audio.volume = 0.7;
            audioRef.current = audio;
            isPlayingRef.current = true;

            audio.onended = () => {
                isPlayingRef.current = false;
            };

            audio.onerror = () => {
                isPlayingRef.current = false;
            };

            // Use play promise to handle interruption
            const playPromise = audio.play();
            
            if (playPromise !== undefined) {
                playPromise
                    .then(() => {
                        // Audio played successfully
                    })
                    .catch((error) => {
                        // Silently handle play interruption errors
                        if (error.name !== 'AbortError' && error.name !== 'NotAllowedError') {
                            console.debug('Audio playback issue:', error.message);
                        }
                        isPlayingRef.current = false;
                    });
            }
        } catch (error) {
            console.debug('Error playing alarm:', error);
            isPlayingRef.current = false;
        }
    }, [currentUser?.alarm_enabled]);

    // Cleanup on unmount
    useEffect(() => {
        return () => {
            if (audioRef.current) {
                audioRef.current.pause();
                audioRef.current = null;
            }
            isPlayingRef.current = false;
        };
    }, []);

    const handleSendNotification = async (delayTime) => {
        setIsSending(true);
        try {
            if (!appointment.client_email) {
                toast.error("No client email found for this appointment.");
                return;
            }

            // Using currentUser instead of user
            const settings = JSON.parse(currentUser.late_notification_settings || '{}');
            let emailTemplate = settings.email_template || `Hi {client_name},\n\nThis is a quick update regarding our appointment for "{appointment_title}". I'm running about {delay_time} minutes late. My apologies for the delay.\n\nSee you soon!\n{your_name}`;

            const emailBody = emailTemplate
                .replace('{client_name}', appointment.client_name || 'there')
                .replace('{appointment_title}', appointment.title)
                .replace('{delay_time}', delayTime)
                .replace('{your_name}', currentUser.full_name); // Using currentUser instead of user

            await base44.integrations.Core.SendEmail({
                to: appointment.client_email,
                subject: `Update on our appointment: ${appointment.title}`,
                body: emailBody,
            });

            const currentSentCount = appointment.late_notifications_sent || 0;
            await base44.entities.Appointment.update(appointment.id, {
                late_notifications_sent: currentSentCount + 1,
            });

            toast.success(`Notification sent for ${delayTime} min delay.`);
            if (onNotificationSent) {
                onNotificationSent();
            }
            playAlarm('beep'); // Example: Play a beep sound after sending notification
        } catch (error) {
            console.error("Failed to send late notification:", error);
            toast.error("Failed to send notification.");
        } finally {
            setIsSending(false);
        }
    };
    
    // Using currentUser instead of user
    const delayOptions = JSON.parse(currentUser?.late_notification_settings || '{}').times || [15, 30, 45, 60];

    return (
        <DropdownMenu>
            <DropdownMenuTrigger asChild>
                <Button variant="destructive" size="sm" disabled={isSending}>
                    {isSending ? (
                        <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                    ) : (
                        <Send className="w-4 h-4 mr-2" />
                    )}
                    Notify Client: Running Late
                </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
                <DropdownMenuLabel>Notify client of delay:</DropdownMenuLabel>
                <DropdownMenuSeparator />
                {delayOptions.map(time => (
                    <DropdownMenuItem key={time} onClick={() => handleSendNotification(time)} disabled={isSending}>
                        <Clock className="w-4 h-4 mr-2" />
                        Running {time} minutes late
                    </DropdownMenuItem>
                ))}
            </DropdownMenuContent>
        </DropdownMenu>
    );
}

import React, { useState } from 'react';
import { base44 } from '@/api/base44Client';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
  DialogDescription,
} from '@/components/ui/dialog';
import {
  Calendar,
  Clock,
  MapPin,
  User,
  RefreshCw,
  Trash2,
  Edit,
  AlertCircle,
  XCircle,
  Save
} from 'lucide-react';
import { format } from 'date-fns';
import { toast } from 'sonner';

export default function RecurringEventManager({ appointment, onClose, onUpdated, onEditFull }) {
  const queryClient = useQueryClient();
  const [deleteOption, setDeleteOption] = useState('this');
  const [isEditing, setIsEditing] = useState(false);
  const [editedTitle, setEditedTitle] = useState(appointment.title || '');
  const [editedTime, setEditedTime] = useState(appointment.scheduled_time || '09:00');

  const cancelRecurringMutation = useMutation({
    mutationFn: async () => {
      if (deleteOption === 'this' && appointment.isRecurringInstance) {
        // Add this date to the cancelled instances list
        const cancelledInstances = appointment.cancelled_instances 
          ? JSON.parse(appointment.cancelled_instances) 
          : [];
        
        cancelledInstances.push(appointment.instanceDate);
        
        return await base44.entities.Appointment.update(appointment.id, {
          cancelled_instances: JSON.stringify(cancelledInstances)
        });
      } else {
        // Cancel the entire series
        return await base44.entities.Appointment.update(appointment.id, {
          status: 'cancelled'
        });
      }
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['appointments'] });
      queryClient.invalidateQueries({ queryKey: ['allUpcomingEvents'] });
      toast.success(deleteOption === 'this' ? 'This instance cancelled' : 'Recurring series cancelled');
      if (onUpdated) onUpdated();
      onClose();
    },
    onError: (error) => {
      toast.error('Failed to cancel: ' + error.message);
    }
  });

  const stopRecurrenceMutation = useMutation({
    mutationFn: async () => {
      return await base44.entities.Appointment.update(appointment.id, {
        recurrence_end_date: appointment.instanceDate || format(new Date(), 'yyyy-MM-dd')
      });
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['appointments'] });
      queryClient.invalidateQueries({ queryKey: ['allUpcomingEvents'] });
      toast.success('Recurring series stopped');
      if (onUpdated) onUpdated();
      onClose();
    },
    onError: (error) => {
      toast.error('Failed to stop recurrence: ' + error.message);
    }
  });

  const updateEventMutation = useMutation({
    mutationFn: async () => {
      return await base44.entities.Appointment.update(appointment.id, {
        title: editedTitle,
        scheduled_time: editedTime
      });
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['appointments'] });
      queryClient.invalidateQueries({ queryKey: ['allUpcomingEvents'] });
      toast.success('Recurring event updated');
      if (onUpdated) onUpdated();
      onClose();
    },
    onError: (error) => {
      toast.error('Failed to update: ' + error.message);
    }
  });

  const getRecurrenceDescription = () => {
    if (!appointment.is_recurring) return 'One-time event';
    
    let desc = `Repeats ${appointment.recurrence_pattern}`;
    if (appointment.recurrence_pattern === 'weekly' && appointment.recurrence_days) {
      const dayNames = {
        mon: 'Mon', tue: 'Tue', wed: 'Wed', thu: 'Thu', 
        fri: 'Fri', sat: 'Sat', sun: 'Sun'
      };
      const days = appointment.recurrence_days.split(',').map(d => dayNames[d]).join(', ');
      desc += ` on ${days}`;
    }
    if (appointment.recurrence_end_date) {
      desc += ` until ${format(new Date(appointment.recurrence_end_date), 'MMM d, yyyy')}`;
    }
    return desc;
  };

  return (
    <Dialog open={true} onOpenChange={onClose}>
      <DialogContent className="max-w-2xl">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <RefreshCw className="w-5 h-5 text-indigo-600" />
            Manage Recurring Event
          </DialogTitle>
          <DialogDescription>
            {appointment.isRecurringInstance ? 'This is an instance of a recurring series' : 'This is a recurring event'}
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-6">
          {/* Event Details */}
          <Card className="border-2 border-indigo-200 bg-indigo-50 dark:bg-indigo-900/20">
            <CardContent className="pt-6">
              <div className="space-y-3">
                {isEditing ? (
                  <div className="space-y-4">
                    <div className="space-y-2">
                      <Label htmlFor="edit-title">Event Title</Label>
                      <Input
                        id="edit-title"
                        value={editedTitle}
                        onChange={(e) => setEditedTitle(e.target.value)}
                        placeholder="Event name"
                      />
                    </div>
                    <div className="space-y-2">
                      <Label htmlFor="edit-time">Time</Label>
                      <Input
                        id="edit-time"
                        type="time"
                        value={editedTime}
                        onChange={(e) => setEditedTime(e.target.value)}
                      />
                    </div>
                    <p className="text-xs text-slate-500">
                      Note: Changes will apply to all instances in this series.
                    </p>
                  </div>
                ) : (
                  <>
                    <div className="flex items-center gap-3">
                      <Calendar className="w-5 h-5 text-indigo-600" />
                      <div>
                        <p className="font-semibold">{appointment.title}</p>
                        <p className="text-sm text-slate-600 dark:text-slate-400">
                          {getRecurrenceDescription()}
                        </p>
                      </div>
                    </div>
                    
                    {appointment.isRecurringInstance && (
                      <div className="flex items-center gap-3 pl-8">
                        <Clock className="w-4 h-4 text-slate-500" />
                        <p className="text-sm text-slate-600 dark:text-slate-400">
                          This instance: {format(new Date(appointment.instanceDate), 'EEEE, MMM d, yyyy')} at {appointment.scheduled_time}
                        </p>
                      </div>
                    )}

                    {appointment.location_address && (
                      <div className="flex items-center gap-3 pl-8">
                        <MapPin className="w-4 h-4 text-slate-500" />
                        <p className="text-sm text-slate-600 dark:text-slate-400">
                          {appointment.location_address}
                        </p>
                      </div>
                    )}

                    {appointment.client_name && (
                      <div className="flex items-center gap-3 pl-8">
                        <User className="w-4 h-4 text-slate-500" />
                        <p className="text-sm text-slate-600 dark:text-slate-400">
                          {appointment.client_name}
                        </p>
                      </div>
                    )}
                  </>
                )}
              </div>
            </CardContent>
          </Card>

          {/* Edit Button */}
          {!isEditing && (
            <div className="flex gap-2">
              <Button
                variant="outline"
                onClick={() => setIsEditing(true)}
                className="flex-1"
              >
                <Edit className="w-4 h-4 mr-2" />
                Quick Edit (Title & Time)
              </Button>
              {onEditFull && (
                <Button
                  variant="outline"
                  onClick={() => {
                    onClose();
                    onEditFull(appointment);
                  }}
                  className="flex-1"
                >
                  <Edit className="w-4 h-4 mr-2" />
                  Full Edit
                </Button>
              )}
            </div>
          )}

          {/* Cancel Options */}
          <div className="space-y-3">
            <h4 className="font-semibold text-sm text-slate-900 dark:text-white">
              What would you like to do?
            </h4>

            {appointment.isRecurringInstance && (
              <label className="flex items-start gap-3 p-4 border-2 rounded-lg cursor-pointer hover:bg-slate-50 dark:hover:bg-slate-800 transition-colors">
                <input
                  type="radio"
                  name="deleteOption"
                  value="this"
                  checked={deleteOption === 'this'}
                  onChange={(e) => setDeleteOption(e.target.value)}
                  className="mt-1"
                />
                <div className="flex-1">
                  <p className="font-semibold text-slate-900 dark:text-white">Cancel only this instance</p>
                  <p className="text-sm text-slate-600 dark:text-slate-400">
                    {format(new Date(appointment.instanceDate), 'EEEE, MMM d, yyyy')} will be skipped
                  </p>
                </div>
              </label>
            )}

            <label className="flex items-start gap-3 p-4 border-2 rounded-lg cursor-pointer hover:bg-slate-50 dark:hover:bg-slate-800 transition-colors">
              <input
                type="radio"
                name="deleteOption"
                value="all"
                checked={deleteOption === 'all'}
                onChange={(e) => setDeleteOption(e.target.value)}
                className="mt-1"
              />
              <div className="flex-1">
                <p className="font-semibold text-slate-900 dark:text-white">Cancel entire series</p>
                <p className="text-sm text-slate-600 dark:text-slate-400">
                  All future instances will be cancelled
                </p>
              </div>
            </label>

            <label className="flex items-start gap-3 p-4 border-2 rounded-lg cursor-pointer hover:bg-slate-50 dark:hover:bg-slate-800 transition-colors">
              <input
                type="radio"
                name="deleteOption"
                value="stop"
                checked={deleteOption === 'stop'}
                onChange={(e) => setDeleteOption(e.target.value)}
                className="mt-1"
              />
              <div className="flex-1">
                <p className="font-semibold text-slate-900 dark:text-white">Stop recurrence after today</p>
                <p className="text-sm text-slate-600 dark:text-slate-400">
                  No more instances will be created
                </p>
              </div>
            </label>
          </div>

          {/* Warning */}
          <div className="p-4 bg-amber-50 dark:bg-amber-900/20 border border-amber-200 dark:border-amber-800 rounded-lg">
            <div className="flex items-start gap-3">
              <AlertCircle className="w-5 h-5 text-amber-600 flex-shrink-0 mt-0.5" />
              <div className="text-sm text-amber-800 dark:text-amber-200">
                {deleteOption === 'this' 
                  ? 'Only this specific occurrence will be cancelled. Other instances will remain.'
                  : deleteOption === 'stop'
                  ? 'The series will stop repeating after this date.'
                  : 'All future occurrences of this event will be permanently cancelled.'}
              </div>
            </div>
          </div>
        </div>

        <DialogFooter className="gap-2">
          <Button variant="outline" onClick={onClose}>
            Go Back
          </Button>
          {isEditing ? (
            <>
              <Button variant="outline" onClick={() => setIsEditing(false)}>
                Cancel Edit
              </Button>
              <Button
                onClick={() => updateEventMutation.mutate()}
                className="bg-indigo-600 hover:bg-indigo-700"
                disabled={updateEventMutation.isLoading}
              >
                <Save className="w-4 h-4 mr-2" />
                Save Changes
              </Button>
            </>
          ) : deleteOption === 'stop' ? (
            <Button
              onClick={() => stopRecurrenceMutation.mutate()}
              className="bg-orange-600 hover:bg-orange-700"
            >
              <XCircle className="w-4 h-4 mr-2" />
              Stop Recurrence
            </Button>
          ) : (
            <Button
              onClick={() => cancelRecurringMutation.mutate()}
              variant="destructive"
            >
              <Trash2 className="w-4 h-4 mr-2" />
              Cancel {deleteOption === 'this' ? 'This Instance' : 'Series'}
            </Button>
          )}
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
import React, { useState, useEffect } from 'react';
import { base44 } from '@/api/base44Client';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Sparkles, Clock, Loader2, Calendar, CheckCircle2 } from 'lucide-react';
import { format, isToday } from 'date-fns';
import { toast } from 'sonner';

export default function SmartSchedulingAssistant({ 
    selectedDate, 
    selectedTime,
    appointmentType,
    location,
    duration,
    currentUser,
    existingAppointments,
    existingShowings,
    existingOpenHouses,
    onSelectTime 
}) {
    const [suggestions, setSuggestions] = useState([]);
    const [isLoading, setIsLoading] = useState(false);
    const [showSuggestions, setShowSuggestions] = useState(false);

    const generateSmartSuggestions = async () => {
        setIsLoading(true);
        setShowSuggestions(true);

        try {
            // Get all events for the selected date
            const dateStr = format(selectedDate, 'yyyy-MM-dd');
            const dayEvents = [
                ...existingAppointments.filter(a => a.scheduled_date === dateStr),
                ...existingShowings.filter(s => s.scheduled_date === dateStr),
                ...existingOpenHouses.filter(oh => oh.date === dateStr)
            ].sort((a, b) => {
                const timeA = a.scheduled_time || a.start_time || '00:00';
                const timeB = b.scheduled_time || b.start_time || '00:00';
                return timeA.localeCompare(timeB);
            });

            // Build schedule context
            const scheduleContext = dayEvents.map(e => ({
                time: e.scheduled_time || e.start_time,
                duration: e.duration_minutes || 60,
                location: e.location_address,
                type: e.type || e.appointment_type
            }));

            // Get working hours
            const workStart = currentUser?.working_hours_start || '09:00';
            const workEnd = currentUser?.working_hours_end || '17:00';

            // If selecting for today, get current time to avoid suggesting past times
            const now = new Date();
            const isTodaySelection = isToday(selectedDate);
            const currentTime = isTodaySelection ? format(now, 'HH:mm') : null;

            // Use AI to suggest optimal times
            const aiResponse = await base44.integrations.Core.InvokeLLM({
                prompt: `You are a scheduling assistant for a real estate agent. 

Agent's working hours: ${workStart} - ${workEnd}
Date: ${format(selectedDate, 'EEEE, MMMM d, yyyy')}
${isTodaySelection ? `IMPORTANT: Current time is ${currentTime}. DO NOT suggest any times before ${currentTime}. Only suggest future times.` : ''}
Appointment type: ${appointmentType}
Duration needed: ${duration} minutes
Location: ${location || 'Not specified'}

Current schedule for this day:
${scheduleContext.length > 0 ? scheduleContext.map((e, i) => `${i + 1}. ${e.time} - ${e.type} at ${e.location || 'unknown'} (${e.duration} min)`).join('\n') : 'No appointments scheduled yet'}

Agent's office location: ${currentUser?.office_address || 'Not specified'}
${location ? `Appointment location: ${location}` : ''}

Analyze the schedule and suggest 3-5 optimal time slots for this appointment, considering:
1. ${isTodaySelection ? 'CRITICAL: Only suggest times AFTER ' + currentTime + ' (do not suggest past times!)' : 'No scheduling conflicts'}
2. No scheduling conflicts with existing appointments
3. Buffer time between appointments (15-30 minutes)
4. Travel time if location is far from office or previous appointments
5. Avoid scheduling too early or too late
6. Group appointments in same area when possible
7. Prefer mid-morning (10am-11am) or mid-afternoon (2pm-3pm) for best productivity

${isTodaySelection ? 'REMEMBER: Current time is ' + currentTime + '. Reject any time slots before this time!' : ''}

Return a JSON array of suggested time slots with reasoning.`,
                response_json_schema: {
                    type: "object",
                    properties: {
                        suggestions: {
                            type: "array",
                            items: {
                                type: "object",
                                properties: {
                                    time: { type: "string", description: "Time in HH:MM format" },
                                    reason: { type: "string", description: "Why this time is optimal" },
                                    score: { type: "number", description: "Optimization score 0-100" },
                                    benefits: { 
                                        type: "array", 
                                        items: { type: "string" },
                                        description: "Key benefits of this time slot"
                                    }
                                },
                                required: ["time", "reason", "score"]
                            }
                        }
                    },
                    required: ["suggestions"]
                }
            });

            if (aiResponse?.suggestions && aiResponse.suggestions.length > 0) {
                // Filter out any past times if selecting for today
                let validSuggestions = aiResponse.suggestions;
                
                if (isTodaySelection) {
                    const nowTime = format(now, 'HH:mm');
                    validSuggestions = aiResponse.suggestions.filter(s => s.time > nowTime);
                    
                    if (validSuggestions.length === 0) {
                        toast.warning("All AI suggestions were in the past. Please select a time manually.");
                        setSuggestions([]);
                        setIsLoading(false);
                        return;
                    }
                }
                
                // Sort by score
                const sortedSuggestions = validSuggestions
                    .sort((a, b) => b.score - a.score)
                    .slice(0, 5);
                
                setSuggestions(sortedSuggestions);
                toast.success(`Found ${sortedSuggestions.length} optimal time slots!`);
            } else {
                toast.info("No specific suggestions - your schedule is flexible for this day");
                setSuggestions([]);
            }
        } catch (error) {
            console.error('Error generating suggestions:', error);
            toast.error("Could not generate suggestions. Please select time manually.");
            setSuggestions([]);
        } finally {
            setIsLoading(false);
        }
    };

    // Auto-generate suggestions when date changes
    useEffect(() => {
        if (selectedDate && appointmentType && !selectedTime) {
            generateSmartSuggestions();
        }
    }, [selectedDate, appointmentType]);

    const getScoreColor = (score) => {
        if (score >= 90) return 'bg-green-500';
        if (score >= 75) return 'bg-blue-500';
        if (score >= 60) return 'bg-amber-500';
        return 'bg-slate-500';
    };

    const getScoreBadgeColor = (score) => {
        if (score >= 90) return 'bg-green-100 text-green-800 border-green-300';
        if (score >= 75) return 'bg-blue-100 text-blue-800 border-blue-300';
        if (score >= 60) return 'bg-amber-100 text-amber-800 border-amber-300';
        return 'bg-slate-100 text-slate-800 border-slate-300';
    };

    if (!showSuggestions) return null;

    return (
        <Card className="border-2 border-indigo-200 dark:border-indigo-800 bg-gradient-to-br from-indigo-50 to-purple-50 dark:from-indigo-950 dark:to-purple-950">
            <CardContent className="p-4 space-y-4">
                <div className="flex items-center justify-between">
                    <div className="flex items-center gap-2">
                        <div className="w-8 h-8 rounded-lg bg-gradient-to-br from-indigo-500 to-purple-600 flex items-center justify-center">
                            <Sparkles className="w-4 h-4 text-white" />
                        </div>
                        <div>
                            <h3 className="font-semibold text-slate-900 dark:text-white">
                                AI Scheduling Assistant
                            </h3>
                            <p className="text-xs text-slate-600 dark:text-slate-400">
                                Optimized time slots for {format(selectedDate, 'MMMM d')}
                                {isToday(selectedDate) && <span className="ml-1 text-amber-600 dark:text-amber-400">(Today - Future times only)</span>}
                            </p>
                        </div>
                    </div>
                    {!isLoading && suggestions.length > 0 && (
                        <Button
                            onClick={generateSmartSuggestions}
                            size="sm"
                            variant="outline"
                            className="text-xs"
                        >
                            <Sparkles className="w-3 h-3 mr-1" />
                            Refresh
                        </Button>
                    )}
                </div>

                {isLoading ? (
                    <div className="flex items-center justify-center py-8">
                        <Loader2 className="w-6 h-6 animate-spin text-indigo-600" />
                        <span className="ml-2 text-sm text-slate-600 dark:text-slate-400">
                            Analyzing your schedule...
                        </span>
                    </div>
                ) : suggestions.length > 0 ? (
                    <div className="space-y-2">
                        {suggestions.map((suggestion, index) => (
                            <div
                                key={index}
                                onClick={() => {
                                    onSelectTime(suggestion.time);
                                    toast.success(`Selected ${suggestion.time} - ${suggestion.reason}`);
                                }}
                                className="p-3 bg-white dark:bg-slate-900 rounded-lg border-2 border-slate-200 dark:border-slate-700 hover:border-indigo-400 dark:hover:border-indigo-600 cursor-pointer transition-all hover:shadow-md group"
                            >
                                <div className="flex items-start justify-between gap-3">
                                    <div className="flex-1">
                                        <div className="flex items-center gap-2 mb-2">
                                            <Clock className="w-4 h-4 text-indigo-600 dark:text-indigo-400" />
                                            <span className="font-bold text-lg text-slate-900 dark:text-white">
                                                {suggestion.time}
                                            </span>
                                            {index === 0 && (
                                                <Badge className="bg-gradient-to-r from-yellow-400 to-amber-500 text-white text-xs">
                                                    ‚≠ê Best Match
                                                </Badge>
                                            )}
                                        </div>
                                        <p className="text-sm text-slate-700 dark:text-slate-300 mb-2">
                                            {suggestion.reason}
                                        </p>
                                        {suggestion.benefits && suggestion.benefits.length > 0 && (
                                            <div className="flex flex-wrap gap-1">
                                                {suggestion.benefits.map((benefit, i) => (
                                                    <Badge 
                                                        key={i} 
                                                        variant="outline"
                                                        className="text-xs bg-blue-50 dark:bg-blue-900/20 text-blue-700 dark:text-blue-300 border-blue-200 dark:border-blue-800"
                                                    >
                                                        <CheckCircle2 className="w-3 h-3 mr-1" />
                                                        {benefit}
                                                    </Badge>
                                                ))}
                                            </div>
                                        )}
                                    </div>
                                    <div className="flex flex-col items-end gap-2">
                                        <Badge 
                                            variant="outline"
                                            className={getScoreBadgeColor(suggestion.score)}
                                        >
                                            {suggestion.score}% match
                                        </Badge>
                                        <Button
                                            size="sm"
                                            className="opacity-0 group-hover:opacity-100 transition-opacity"
                                        >
                                            Select
                                        </Button>
                                    </div>
                                </div>
                                {/* Progress bar for score */}
                                <div className="mt-3 h-1 w-full bg-slate-200 dark:bg-slate-700 rounded-full overflow-hidden">
                                    <div 
                                        className={`h-full ${getScoreColor(suggestion.score)} transition-all`}
                                        style={{ width: `${suggestion.score}%` }}
                                    />
                                </div>
                            </div>
                        ))}
                    </div>
                ) : (
                    <div className="text-center py-6">
                        <Calendar className="w-12 h-12 mx-auto text-slate-400 mb-2" />
                        <p className="text-sm text-slate-600 dark:text-slate-400">
                            Your schedule is wide open for this day!
                        </p>
                        <p className="text-xs text-slate-500 dark:text-slate-500 mt-1">
                            Pick any time that works best for you
                        </p>
                    </div>
                )}

                <div className="pt-3 border-t border-slate-200 dark:border-slate-700">
                    <p className="text-xs text-slate-500 dark:text-slate-400 text-center">
                        üí° Times are optimized for productivity, travel efficiency, and work-life balance
                        {isToday(selectedDate) && <span className="block mt-1 text-amber-600 dark:text-amber-400">‚ö†Ô∏è Only future times shown for today</span>}
                    </p>
                </div>
            </CardContent>
        </Card>
    );
}
